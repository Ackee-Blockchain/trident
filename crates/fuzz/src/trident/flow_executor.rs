use std::thread;
use std::time::Instant;
use trident_fuzz_metrics::TridentFuzzingData;

use crate::trident::Trident;

/// Configuration constants for the flow executor
mod config {
    use std::time::Duration;

    /// How often to update progress bars (in flow calls)
    pub const PROGRESS_UPDATE_INTERVAL: u64 = 100;

    /// How often to update progress bars (in time)
    pub const PROGRESS_UPDATE_DURATION: Duration = Duration::from_millis(50);

    /// Default seed size in bytes
    pub const SEED_SIZE: usize = 32;

    /// Environment variable names
    pub const ENV_FUZZ_DEBUG: &str = "TRIDENT_FUZZ_DEBUG";
    pub const ENV_FUZZ_SEED: &str = "TRIDENT_FUZZ_SEED";
    pub const ENV_FUZZING_METRICS: &str = "FUZZING_METRICS";
}

pub trait FlowExecutor: Send + 'static + Sized {
    fn new() -> Self;
    fn execute_flows(
        &mut self,
        flow_calls_per_iteration: u64,
    ) -> Result<(), crate::error::FuzzingError>;
    fn trident_mut(&mut self) -> &mut Trident;
    fn reset_fuzz_accounts(&mut self);

    /// Generated by macro: empty or contains LLVM coverage calls
    fn handle_llvm_coverage(&mut self, current_iteration: u64);

    fn fuzz(iterations: u64, flow_calls_per_iteration: u64) {
        if std::env::var(config::ENV_FUZZ_DEBUG).is_ok() {
            println!("Debug mode detected: Running single iteration with provided seed");
            Self::fuzz_single_threaded(1, flow_calls_per_iteration);
            return;
        }

        Self::setup_panic_handler();
        let master_seed = Self::get_or_generate_master_seed();
        let num_threads = thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(1)
            .min(iterations as usize);

        if num_threads <= 1 || iterations <= 1 {
            Self::fuzz_single_threaded(iterations, flow_calls_per_iteration);
            return;
        }

        Self::fuzz_parallel(
            iterations,
            flow_calls_per_iteration,
            num_threads,
            master_seed,
        );
    }

    fn setup_panic_handler() {
        std::panic::set_hook(Box::new(|_info| {
            // Suppress panic messages for cleaner fuzzing output
        }));
    }

    fn get_or_generate_master_seed() -> [u8; config::SEED_SIZE] {
        if let Ok(seed_hex) = std::env::var(config::ENV_FUZZ_SEED) {
            Self::parse_hex_seed(&seed_hex)
        } else {
            Self::generate_random_seed()
        }
    }

    fn parse_hex_seed(seed_hex: &str) -> [u8; config::SEED_SIZE] {
        let seed_bytes = hex::decode(seed_hex)
            .unwrap_or_else(|_| panic!("Invalid hex string in seed: {}", seed_hex));

        if seed_bytes.len() != config::SEED_SIZE {
            panic!(
                "Seed must be exactly {} bytes ({} hex characters), got: {}",
                config::SEED_SIZE,
                config::SEED_SIZE * 2,
                seed_bytes.len()
            );
        }

        let mut seed = [0u8; config::SEED_SIZE];
        seed.copy_from_slice(&seed_bytes);
        seed
    }

    fn generate_random_seed() -> [u8; config::SEED_SIZE] {
        let mut seed = [0u8; config::SEED_SIZE];
        if let Err(err) = getrandom::fill(&mut seed) {
            panic!("Failed to generate random seed: {}", err);
        }
        seed
    }

    fn output_metrics_if_enabled(fuzzing_data: &TridentFuzzingData) {
        if std::env::var(config::ENV_FUZZING_METRICS).is_ok() {
            if let Err(e) = fuzzing_data.generate() {
                eprintln!("Warning: Failed to generate metrics: {}", e);
            }
        }
    }

    fn fuzz_single_threaded(iterations: u64, flow_calls_per_iteration: u64) {
        let mut fuzzer = Self::new();

        // Set debug seed if in debug mode
        if let Ok(debug_seed_hex) = std::env::var(config::ENV_FUZZ_DEBUG) {
            let debug_seed = Self::parse_hex_seed(&debug_seed_hex);
            println!("Using debug seed: {}", debug_seed_hex);
            fuzzer.trident_mut().set_master_seed_for_debug(debug_seed);
        }

        let total_flow_calls = iterations * flow_calls_per_iteration;

        // Setup progress bar
        let pb = indicatif::ProgressBar::new(total_flow_calls);
        pb.set_style(
            indicatif::ProgressStyle::with_template(
                "{spinner:.green} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {pos}/{len} ({percent}%) [{eta_precise}] {msg}"
            )
            .unwrap()
            .progress_chars("#>-"),
        );
        pb.set_message(format!(
            "Fuzzing {} iterations with {} flow calls each...",
            iterations, flow_calls_per_iteration
        ));

        // Main fuzzing loop
        for i in 0..iterations {
            let _result = fuzzer.execute_flows(flow_calls_per_iteration);
            fuzzer.trident_mut().next_iteration();
            fuzzer.reset_fuzz_accounts();

            // Handle coverage profiling if enabled
            Self::handle_coverage_if_enabled(&mut fuzzer, i + 1);

            pb.inc(flow_calls_per_iteration);
            pb.set_message(format!("Iteration {}/{} completed", i + 1, iterations));
        }

        pb.finish_with_message("Fuzzing completed!");

        let fuzzing_data = fuzzer.trident_mut().get_fuzzing_data();
        Self::output_metrics_if_enabled(&fuzzing_data);
    }

    fn fuzz_parallel(
        iterations: u64,
        flow_calls_per_iteration: u64,
        num_threads: usize,
        master_seed: [u8; 32],
    ) {
        let iterations_per_thread = iterations / num_threads as u64;
        let total_flow_calls = iterations * flow_calls_per_iteration;

        let mut handles = Vec::new();

        // Create progress bar for overall status
        let main_pb = indicatif::ProgressBar::new(total_flow_calls);
        main_pb.set_style(
            indicatif::ProgressStyle::with_template(
                "Overall: {spinner:.green} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {pos}/{len} ({percent}%) [{eta_precise}] {msg}"
            )
            .unwrap()
            .progress_chars("#>-"),
        );
        main_pb.set_message(format!(
            "Fuzzing with {} threads - {} iterations with {} flow calls each",
            num_threads, iterations, flow_calls_per_iteration
        ));

        for thread_id in 0..num_threads {
            let thread_iterations = iterations_per_thread;

            if thread_iterations == 0 {
                continue;
            }

            let main_pb_clone = main_pb.clone();
            let handle = thread::spawn(move || -> TridentFuzzingData {
                let mut fuzzer = Self::new();
                fuzzer
                    .trident_mut()
                    .set_master_seed_and_thread_id(master_seed, thread_id);

                // Progress update tracking
                let mut last_update = Instant::now();
                let mut local_counter = 0u64;

                for i in 0..thread_iterations {
                    let _ = fuzzer.execute_flows(flow_calls_per_iteration);
                    fuzzer.trident_mut().next_iteration();
                    fuzzer.reset_fuzz_accounts();

                    // Handle coverage profiling if enabled (only thread 0 to avoid duplicates)
                    if thread_id == 0 {
                        Self::handle_coverage_if_enabled(&mut fuzzer, i + 1);
                    }

                    local_counter += flow_calls_per_iteration;

                    // Update progress bars with granularity control
                    let should_update = local_counter >= config::PROGRESS_UPDATE_INTERVAL
                        || last_update.elapsed() >= config::PROGRESS_UPDATE_DURATION
                        || i == thread_iterations - 1; // Always update on last iteration

                    if should_update {
                        main_pb_clone.inc(local_counter);
                        local_counter = 0;
                        last_update = Instant::now();
                    }
                }

                // Ensure final update
                if local_counter > 0 {
                    main_pb_clone.inc(local_counter);
                }

                fuzzer.trident_mut().get_fuzzing_data()
            });

            handles.push(handle);
        }

        let mut fuzzing_data = TridentFuzzingData::with_master_seed(master_seed);

        // Collect metrics from all threads
        for handle in handles {
            match handle.join() {
                Ok(thread_metrics) => {
                    fuzzing_data._merge(thread_metrics);
                }
                Err(err) => {
                    if let Some(s) = err.downcast_ref::<&str>() {
                        eprintln!("Thread panicked with message: {}", s);
                    } else if let Some(s) = err.downcast_ref::<String>() {
                        eprintln!("Thread panicked with message: {}", s);
                    } else {
                        eprintln!("Thread panicked with unknown error type");
                    }
                    panic!("Error joining thread: {:?}", err);
                }
            }
        }

        main_pb.finish_with_message("Parallel fuzzing completed!");

        let exit_code = fuzzing_data.get_exit_code();
        Self::output_metrics_if_enabled(&fuzzing_data);
        println!("MASTER SEED used: {:?}", &hex::encode(master_seed));

        std::process::exit(exit_code);
    }

    fn handle_coverage_if_enabled(fuzzer: &mut Self, current_iteration: u64) {
        let loopcount = std::env::var("FUZZER_LOOPCOUNT")
            .ok()
            .and_then(|val| val.parse::<u64>().ok())
            .unwrap_or(0);

        if loopcount > 0 && current_iteration > 0 && current_iteration % loopcount == 0 {
            // Call the macro-generated LLVM method
            fuzzer.handle_llvm_coverage(current_iteration);

            // Notify extension to update coverage decorations
            Self::notify_coverage_extension();
        }
    }

    fn notify_coverage_extension() {
        let coverage_server_port =
            std::env::var("COVERAGE_SERVER_PORT").unwrap_or_else(|_| "58432".to_string());

        let url = format!(
            "http://localhost:{}/update-decorations",
            coverage_server_port
        );
        std::thread::spawn(move || {
            let client = reqwest::blocking::Client::new();
            let _ = client
                .post(&url)
                .header("Content-Type", "application/json")
                .body("")
                .send();
        });
    }
}
