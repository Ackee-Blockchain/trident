//! # Trident Generated Types
//! 
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

{% for program in programs %}
// ----------------------------------------------------------------------------
// Program: {{ program.module_name }}
// ----------------------------------------------------------------------------
pub mod {{ program.module_name }} {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for {{ program.name }}
    pub fn program_id() -> Pubkey {
        pubkey!("{{ program.program_id }}")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

{% for instruction in program.instructions %}
    // ....................................................................
    // Instruction: {{ instruction.camel_name }}
    // ....................................................................

    /// Main instruction struct for {{ instruction.camel_name }}
    pub struct {{ instruction.camel_name }}Instruction {
        pub accounts: {{ instruction.camel_name }}InstructionAccountMetas,
        pub data: {{ instruction.camel_name }}InstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for {{ instruction.camel_name }} instruction
    #[derive(Debug, Clone, Default)]
    pub struct {{ instruction.camel_name }}InstructionAccountMetas {
        {% for account in instruction.accounts %}
        {% if account.is_composite %}
        pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccountMetas,
        {% else %}
        pub {{ account.name }}: AccountMeta,
        {% endif %}
        {% endfor %}
    }

    /// Account pubkeys for {{ instruction.camel_name }} instruction
    #[derive(Debug, Clone)]
    pub struct {{ instruction.camel_name }}InstructionAccounts {
    {% for account in instruction.accounts %}
    {% if not account.address %}
    {% if account.is_composite %}
    pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
    {% else %}
    pub {{ account.name }}: Pubkey,
    {% endif %}
    {% endif %}
    {% endfor %}
}

    impl {{ instruction.camel_name }}InstructionAccounts {
        pub fn new(
        {% for account in instruction.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
            {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
        {% else %}
            {{ account.name }}: Pubkey,
        {% endif %}
        {% endif %}
        {% endfor %}
        ) -> Self {
            Self {
            {% for account in instruction.accounts %}
            {% if not account.address %}
                {{ account.name }},
            {% endif %}
            {% endfor %}
            }
        }
    }

    /// Instruction data for {{ instruction.camel_name }}
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct {{ instruction.camel_name }}InstructionData {
    {% for field in instruction.data_fields %}
    pub {{ field.name }}: {{ field.rust_type }},
    {% endfor %}
}

    impl {{ instruction.camel_name }}InstructionData {
        pub fn new(
        {% for field in instruction.data_fields %}
            {{ field.name }}: {{ field.rust_type }},
        {% endfor %}
        ) -> Self {
            Self {
            {% for field in instruction.data_fields %}
                {{ field.name }},
            {% endfor %}
            }
        }
    }

    /// Implementation for {{ instruction.camel_name }}Instruction
    impl {{ instruction.camel_name }}Instruction {
    fn discriminator() -> [u8; 8] {
        [{% for byte in instruction.discriminator %}{{ byte }}u8{% if not loop.last %}, {% endif %}{% endfor %}]
    }

    pub fn data(data: {{ instruction.camel_name }}InstructionData) -> Self {
        Self {
            accounts: {{ instruction.camel_name }}InstructionAccountMetas::default(),
            data,
            remaining_accounts: Vec::new(),
        }
    }

    pub fn accounts(
        mut self,
        accounts: {{ instruction.camel_name }}InstructionAccounts,
    ) -> Self {
        {% for account in instruction.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
        self.accounts.{{ account.name }}.set_from_accounts(accounts.{{ account.name }});
        {% else %}
        {% if account.is_writable and account.is_signer %}
        self.accounts.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, true);
        {% elif account.is_signer %}
        self.accounts.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, true);
        {% elif account.is_writable %}
        self.accounts.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, false);
        {% else %}
        self.accounts.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, false);
        {% endif %}
        {% endif %}
        {% else %}
        {% if account.is_writable %}
        self.accounts.{{ account.name }} = AccountMeta::new(pubkey!("{{ account.address }}"), false);
        {% else %}
        self.accounts.{{ account.name }} = AccountMeta::new_readonly(pubkey!("{{ account.address }}"), false);
        {% endif %}
        {% endif %}
        {% endfor %}
        self
    }

    pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
        self.remaining_accounts = accounts;
        self
    }

    fn to_account_metas(&self) -> Vec<AccountMeta> {
        let mut metas = Vec::new();
        {% for account in instruction.accounts %}
        {% if account.is_composite %}
        metas.extend(self.accounts.{{ account.name }}.to_account_metas());
        {% else %}
        metas.push(self.accounts.{{ account.name }}.clone());
        {% endif %}
        {% endfor %}
        metas.extend(self.remaining_accounts.clone());
        metas
    }

    pub fn instruction(&self) -> Instruction {
        let mut buffer: Vec<u8> = Vec::new();

        buffer.extend_from_slice(&Self::discriminator());

        self.data.serialize(&mut buffer).unwrap();

        Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
    }
}

{% endfor %}

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------

    {% for composite in program.composite_accounts %}
    /// Composite Account: {{ composite.name }}
    #[derive(Debug, Clone, Default)]
    pub struct {{ composite.camel_name }}InstructionAccountMetas {
        {% for account in composite.accounts %}
        {% if account.is_composite %}
        pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccountMetas,
        {% else %}
        pub {{ account.name }}: AccountMeta,
        {% endif %}
        {% endfor %}
    }

    impl {{ composite.camel_name }}InstructionAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();
            {% for account in composite.accounts %}
            {% if account.is_composite %}
            metas.extend(self.{{ account.name }}.to_account_metas());
            {% else %}
            metas.push(self.{{ account.name }}.clone());
            {% endif %}
            {% endfor %}
            metas
        }

        fn set_from_accounts(&mut self, accounts: {{ composite.camel_name }}InstructionAccounts) {
            {% for account in composite.accounts %}
            {% if not account.address %}
            {% if account.is_composite %}
            self.{{ account.name }}.set_from_accounts(accounts.{{ account.name }});
            {% else %}
            {% if account.is_writable and account.is_signer %}
            self.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, true);
            {% elif account.is_signer %}
            self.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, true);
            {% elif account.is_writable %}
            self.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, false);
            {% else %}
            self.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, false);
            {% endif %}
            {% endif %}
            {% endif %}
            {% endfor %}
        }
    }

    #[derive(Debug, Clone)]
    pub struct {{ composite.camel_name }}InstructionAccounts {
        {% for account in composite.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
        pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
        {% else %}
        pub {{ account.name }}: Pubkey,
        {% endif %}
        {% endif %}
        {% endfor %}
    }

    impl {{ composite.camel_name }}InstructionAccounts {
        pub fn new(
        {% for account in composite.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
            {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
        {% else %}
            {{ account.name }}: Pubkey,
        {% endif %}
        {% endif %}
        {% endfor %}
        ) -> Self {
            Self {
            {% for account in composite.accounts %}
            {% if not account.address %}
                {{ account.name }},
            {% endif %}
            {% endfor %}
            }
        }
    }


    {% for nested_composite in composite.nested_composites %}
    #[derive(Debug, Clone, Default)]
    pub struct {{ nested_composite.camel_name }}InstructionAccountMetas {
        {% for account in nested_composite.accounts %}
        {% if account.is_composite %}
        pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccountMetas,
        {% else %}
        pub {{ account.name }}: AccountMeta,
        {% endif %}
        {% endfor %}
    }

    impl {{ nested_composite.camel_name }}InstructionAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();
            {% for account in nested_composite.accounts %}
            {% if account.is_composite %}
            metas.extend(self.{{ account.name }}.to_account_metas());
            {% else %}
            metas.push(self.{{ account.name }}.clone());
            {% endif %}
            {% endfor %}
            metas
        }

        fn set_from_accounts(&mut self, accounts: {{ nested_composite.camel_name }}InstructionAccounts) {
            {% for account in nested_composite.accounts %}
            {% if not account.address %}
            {% if account.is_composite %}
            self.{{ account.name }}.set_from_accounts(accounts.{{ account.name }});
            {% else %}
            {% if account.is_writable and account.is_signer %}
            self.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, true);
            {% elif account.is_signer %}
            self.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, true);
            {% elif account.is_writable %}
            self.{{ account.name }} = AccountMeta::new(accounts.{{ account.name }}, false);
            {% else %}
            self.{{ account.name }} = AccountMeta::new_readonly(accounts.{{ account.name }}, false);
            {% endif %}
            {% endif %}
            {% endif %}
            {% endfor %}
        }
    }

    #[derive(Debug, Clone)]
    pub struct {{ nested_composite.camel_name }}InstructionAccounts {
        {% for account in nested_composite.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
        pub {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
        {% else %}
        pub {{ account.name }}: Pubkey,
        {% endif %}
        {% endif %}
        {% endfor %}
    }

    impl {{ nested_composite.camel_name }}InstructionAccounts {
        pub fn new(
        {% for account in nested_composite.accounts %}
        {% if not account.address %}
        {% if account.is_composite %}
            {{ account.name }}: {{ account.composite_type_name }}InstructionAccounts,
        {% else %}
            {{ account.name }}: Pubkey,
        {% endif %}
        {% endif %}
        {% endfor %}
        ) -> Self {
            Self {
            {% for account in nested_composite.accounts %}
            {% if not account.address %}
                {{ account.name }},
            {% endif %}
            {% endfor %}
            }
        }
    }


    {% endfor %}
    {% endfor %}

}
{% endfor %}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

{% if custom_types %}
{% for custom_type in custom_types %}
{% if custom_type.type == "struct" %}
/// Custom struct: {{ custom_type.name }}
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct {{ custom_type.name }} {
{% if custom_type.fields %}
{% if custom_type.fields.type == "named" %}
{% for field in custom_type.fields.fields %}
    pub {{ field.name }}: {{ field.rust_type }},
{% endfor %}
{% elif custom_type.fields.type == "tuple" %}
{% for field in custom_type.fields.fields %}
    pub field_{{ loop.index0 }}: {{ field.rust_type }},
{% endfor %}
{% endif %}

{% endif %}
}

{% if custom_type.fields %}
impl {{ custom_type.name }} {
    pub fn new(
    {% if custom_type.fields.type == "named" %}
    {% for field in custom_type.fields.fields %}
        {{ field.name }}: {{ field.rust_type }},
    {% endfor %}
    {% elif custom_type.fields.type == "tuple" %}
    {% for field in custom_type.fields.fields %}
        field_{{ loop.index0 }}: {{ field.rust_type }},
    {% endfor %}
    {% endif %}
    ) -> Self {
        Self {
        {% if custom_type.fields.type == "named" %}
        {% for field in custom_type.fields.fields %}
            {{ field.name }},
        {% endfor %}
        {% elif custom_type.fields.type == "tuple" %}
        {% for field in custom_type.fields.fields %}
            field_{{ loop.index0 }},
        {% endfor %}
        {% endif %}
        }
    }
}
{% endif %}
{% elif custom_type.type == "enum" %}
/// Custom enum: {{ custom_type.name }}
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum {{ custom_type.name }} {
{% for variant in custom_type.variants %}
{% if variant.fields %}
{% if variant.fields.type == "named" %}
    {{ variant.name }} {
{% for field in variant.fields.fields %}
        {{ field.name }}: {{ field.rust_type }},
{% endfor %}
    },
{% elif variant.fields.type == "tuple" %}
    {{ variant.name }}({% for field in variant.fields.fields %}{{ field.rust_type }}{% if not loop.last %}, {% endif %}{% endfor %}),
{% endif %}
{% else %}
    {{ variant.name }},
{% endif %}
{% endfor %}
}
{% elif custom_type.type == "type_alias" %}
/// Type alias: {{ custom_type.name }} (not implemented)
// Type alias for {{ custom_type.name }} not implemented
{% endif %}

{% endfor %}
{% endif %}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================

