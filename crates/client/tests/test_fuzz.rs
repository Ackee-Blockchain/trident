use anyhow::Error;
use fehler::throws;
use pretty_assertions::assert_str_eq;
use std::fs;
use std::io::Read;
use std::path::{Path, PathBuf};
use trident_client::___private::Commander;
use trident_idl_spec::Idl;
use trident_template::Template;

#[throws]
#[tokio::test]
async fn test_instruction_generation() {
    let template = setup_template()?;
    verify_instructions(&template).await?;
}

#[throws]
#[tokio::test]
async fn test_transaction_generation() {
    let template = setup_template()?;
    verify_transactions(&template).await?;
}

#[throws]
#[tokio::test]
async fn test_types_generation() {
    let template = setup_template()?;
    verify_types(&template).await?;
}

#[ignore = "FuzzAccounts do not have deterministic order"]
#[throws]
#[tokio::test]
async fn test_fuzz_transactions_generation() {
    let template = setup_template()?;
    verify_fuzz_transactions(&template).await?;
}

#[throws]
#[tokio::test]
async fn test_test_fuzz_generation() {
    let template = setup_template()?;
    verify_test_fuzz(&template).await?;
}

#[throws]
async fn verify_instructions(template: &Template) {
    // Get all instruction files generated by the template
    let generated_instructions = template.get_instructions();

    for (name, generated_content) in generated_instructions {
        let expected_path = construct_path(&format!("fuzz_template/instructions/{}.rs", name));
        let expected_content = fs::read_to_string(&expected_path)?;
        let formatted_content = Commander::format_program_code_nightly(&generated_content).await?;

        assert_str_eq!(
            formatted_content,
            expected_content,
            "Instruction file {} does not match expected content",
            name
        );
    }

    // Verify instructions mod.rs
    let generated_mod = template.get_instructions_mod();
    let expected_mod_path = construct_path("fuzz_template/instructions/mod.rs");
    let expected_mod = fs::read_to_string(&expected_mod_path)?;
    let formatted_mod = Commander::format_program_code_nightly(&generated_mod).await?;

    assert_str_eq!(
        formatted_mod,
        expected_mod,
        "Instructions mod.rs does not match"
    );
}

#[throws]
async fn verify_transactions(template: &Template) {
    // Get all transaction files generated by the template
    let generated_transactions = template.get_transactions();

    for (name, generated_content) in generated_transactions {
        let expected_path = construct_path(&format!("fuzz_template/transactions/{}.rs", name));
        let expected_content = fs::read_to_string(&expected_path)?;
        let formatted_content = Commander::format_program_code_nightly(&generated_content).await?;

        assert_str_eq!(
            formatted_content,
            expected_content,
            "Transaction file {} does not match expected content",
            name
        );
    }

    // Verify transactions mod.rs
    let generated_mod = template.get_transactions_mod();
    let expected_mod_path = construct_path("fuzz_template/transactions/mod.rs");
    let expected_mod = fs::read_to_string(&expected_mod_path)?;
    let formatted_mod = Commander::format_program_code_nightly(&generated_mod).await?;

    assert_str_eq!(
        formatted_mod,
        expected_mod,
        "Transactions mod.rs does not match"
    );
}

#[throws]
async fn verify_types(template: &Template) {
    let generated_types = template.get_custom_types();
    let expected_types_path = construct_path("fuzz_template/types.rs");
    let expected_types = fs::read_to_string(&expected_types_path)?;
    let formatted_types = Commander::format_program_code_nightly(&generated_types).await?;

    assert_str_eq!(formatted_types, expected_types, "Types.rs does not match");
}

#[throws]
async fn verify_fuzz_transactions(template: &Template) {
    let generated_fuzz = template.get_fuzz_transactions();
    let expected_fuzz_path = construct_path("fuzz_template/fuzz_transactions.rs");
    let expected_fuzz = fs::read_to_string(&expected_fuzz_path)?;
    let formatted_fuzz = Commander::format_program_code_nightly(&generated_fuzz).await?;

    assert_str_eq!(
        formatted_fuzz,
        expected_fuzz,
        "Fuzz transactions does not match"
    );
}

#[throws]
async fn verify_test_fuzz(template: &Template) {
    let generated_test_fuzz = template.get_test_fuzz();
    let expected_test_fuzz_path = construct_path("fuzz_template/test_fuzz.rs");
    let expected_test_fuzz = fs::read_to_string(&expected_test_fuzz_path)?;
    let formatted_test_fuzz = Commander::format_program_code_nightly(&generated_test_fuzz).await?;

    assert_str_eq!(
        formatted_test_fuzz,
        expected_test_fuzz,
        "Test fuzz does not match"
    );
}

#[throws]
fn read_idl(idl_name: &str) -> Idl {
    let current_dir = std::env::current_dir()?;
    let anchor_idl_path: PathBuf = [
        current_dir.as_ref(),
        Path::new(&format!("tests/anchor_idl/{}", idl_name)),
    ]
    .iter()
    .collect();

    let mut idl_file = std::fs::File::open(&anchor_idl_path)?;
    let mut json_content = String::new();
    idl_file.read_to_string(&mut json_content)?;

    match serde_json::from_str::<Idl>(&json_content) {
        Ok(parsed_idl) => parsed_idl,
        Err(e) => {
            panic!("Failed to parse {}: {}", anchor_idl_path.display(), e);
        }
    }
}

// Helper function to construct paths relative to CARGO_MANIFEST_DIR
fn construct_path(relative_path: &str) -> PathBuf {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let mut path = PathBuf::from(manifest_dir);
    path.push("tests");
    path.push(relative_path);
    path
}

// Helper function to set up the template
#[throws]
fn setup_template() -> Template {
    let idl_test = read_idl("idl_test.json")?;
    let additional_program = read_idl("additional_program.json")?;

    let mut template = Template::default();
    template.create_template(
        &vec![additional_program, idl_test],
        &["additional_program".to_string(), "idl_test".to_string()],
    );

    template
}
