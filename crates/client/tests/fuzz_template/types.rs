//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: additional_program
// ----------------------------------------------------------------------------
pub mod additional_program {
    use super::*;

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {}

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {}

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {}

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        fn program_id() -> Pubkey {
            pubkey!("8bPSKGoWCdAW8Hu3S1hLHPpBv8BNwse4jDyaXNrj3jWB")
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(Self::program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------
// Program: idl_test
// ----------------------------------------------------------------------------
pub mod idl_test {
    use super::*;

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: ProcessCustomTypes
    // ....................................................................

    /// Main instruction struct for ProcessCustomTypes
    pub struct ProcessCustomTypesInstruction {
        pub accounts: ProcessCustomTypesInstructionAccountMetas,
        pub data: ProcessCustomTypesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ProcessCustomTypes instruction
    #[derive(Debug, Clone, Default)]
    pub struct ProcessCustomTypesInstructionAccountMetas {
        pub composite_account_nested: CompositeAccountNestedInstructionAccountMetas,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,

        pub data_account_2: AccountMeta,

        pub data_account_3: AccountMeta,

        pub data_account_4: AccountMeta,

        pub data_account_5: AccountMeta,

        pub data_account_6: AccountMeta,

        pub composite_account: CompositeAccountInstructionAccountMetas,
    }

    /// Account pubkeys for ProcessCustomTypes instruction
    #[derive(Debug, Clone)]
    pub struct ProcessCustomTypesInstructionAccounts {
        pub composite_account_nested: CompositeAccountNestedInstructionAccounts,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,

        pub data_account_2: Pubkey,

        pub data_account_3: Pubkey,

        pub data_account_4: Pubkey,

        pub data_account_5: Pubkey,

        pub data_account_6: Pubkey,

        pub composite_account: CompositeAccountInstructionAccounts,
    }

    /// Instruction data for ProcessCustomTypes
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ProcessCustomTypesInstructionData {
        pub _input_classic: ClassicStruct,

        pub _input_optional: OptionalFields,

        pub _input_tuple: TupleStruct,

        pub _input_enum: SimpleEnum,

        pub _input_data_enum: DataEnum,

        pub _input_multi_data_enum: MultiDataEnum,

        pub _input_named_fields_enum: NamedFieldsEnum,

        pub _input_generic_enum: GenericEnum,

        pub _input_unit_variants: UnitVariants,

        pub _input_nested: NestedStruct,

        pub _input_default: DefaultStruct,

        pub _input_generic_struct: GenericStruct,
    }

    /// Implementation for ProcessCustomTypesInstruction
    impl ProcessCustomTypesInstruction {
        fn discriminator() -> [u8; 8] {
            [37u8, 23u8, 242u8, 88u8, 134u8, 197u8, 190u8, 108u8]
        }

        fn program_id() -> Pubkey {
            pubkey!("HtD1eaPZ1JqtxcirNtYt3aAhUMoJWZ2Ddtzu4NDZCrhN")
        }

        pub fn data(data: ProcessCustomTypesInstructionData) -> Self {
            Self {
                accounts: ProcessCustomTypesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ProcessCustomTypesInstructionAccounts) -> Self {
            self.accounts
                .composite_account_nested
                .set_from_accounts(accounts.composite_account_nested);

            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.data_account_1 =
                AccountMeta::new_readonly(accounts.data_account_1, false);

            self.accounts.data_account_2 =
                AccountMeta::new_readonly(accounts.data_account_2, false);

            self.accounts.data_account_3 =
                AccountMeta::new_readonly(accounts.data_account_3, false);

            self.accounts.data_account_4 =
                AccountMeta::new_readonly(accounts.data_account_4, false);

            self.accounts.data_account_5 =
                AccountMeta::new_readonly(accounts.data_account_5, false);

            self.accounts.data_account_6 =
                AccountMeta::new_readonly(accounts.data_account_6, false);

            self.accounts
                .composite_account
                .set_from_accounts(accounts.composite_account);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.accounts.composite_account_nested.to_account_metas());

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.data_account_1.clone());

            metas.push(self.accounts.data_account_2.clone());

            metas.push(self.accounts.data_account_3.clone());

            metas.push(self.accounts.data_account_4.clone());

            metas.push(self.accounts.data_account_5.clone());

            metas.push(self.accounts.data_account_6.clone());

            metas.extend(self.accounts.composite_account.to_account_metas());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(Self::program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ProcessRustTypes
    // ....................................................................

    /// Main instruction struct for ProcessRustTypes
    pub struct ProcessRustTypesInstruction {
        pub accounts: ProcessRustTypesInstructionAccountMetas,
        pub data: ProcessRustTypesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ProcessRustTypes instruction
    #[derive(Debug, Clone, Default)]
    pub struct ProcessRustTypesInstructionAccountMetas {
        pub composite_account_nested: CompositeAccountNestedInstructionAccountMetas,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,

        pub data_account_2: AccountMeta,

        pub data_account_3: AccountMeta,

        pub data_account_4: AccountMeta,

        pub data_account_5: AccountMeta,

        pub data_account_6: AccountMeta,

        pub composite_account: CompositeAccountInstructionAccountMetas,
    }

    /// Account pubkeys for ProcessRustTypes instruction
    #[derive(Debug, Clone)]
    pub struct ProcessRustTypesInstructionAccounts {
        pub composite_account_nested: CompositeAccountNestedInstructionAccounts,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,

        pub data_account_2: Pubkey,

        pub data_account_3: Pubkey,

        pub data_account_4: Pubkey,

        pub data_account_5: Pubkey,

        pub data_account_6: Pubkey,

        pub composite_account: CompositeAccountInstructionAccounts,
    }

    /// Instruction data for ProcessRustTypes
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ProcessRustTypesInstructionData {
        pub _input_u8: u8,

        pub _input_u16: u16,

        pub _input_u32: u32,

        pub _input_u64: u64,

        pub _input_i8: i8,

        pub _input_i16: i16,

        pub _input_i32: i32,

        pub _input_i64: i64,

        pub _input_i128: i128,

        pub _input_f32: f32,

        pub _input_f64: f64,

        pub _input_string: String,

        pub _input_vec: Vec<u8>,

        pub _input_vec_string: Vec<String>,

        pub _input_bool: bool,
    }

    /// Implementation for ProcessRustTypesInstruction
    impl ProcessRustTypesInstruction {
        fn discriminator() -> [u8; 8] {
            [74u8, 102u8, 18u8, 245u8, 253u8, 10u8, 252u8, 246u8]
        }

        fn program_id() -> Pubkey {
            pubkey!("HtD1eaPZ1JqtxcirNtYt3aAhUMoJWZ2Ddtzu4NDZCrhN")
        }

        pub fn data(data: ProcessRustTypesInstructionData) -> Self {
            Self {
                accounts: ProcessRustTypesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ProcessRustTypesInstructionAccounts) -> Self {
            self.accounts
                .composite_account_nested
                .set_from_accounts(accounts.composite_account_nested);

            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.data_account_1 =
                AccountMeta::new_readonly(accounts.data_account_1, false);

            self.accounts.data_account_2 =
                AccountMeta::new_readonly(accounts.data_account_2, false);

            self.accounts.data_account_3 =
                AccountMeta::new_readonly(accounts.data_account_3, false);

            self.accounts.data_account_4 =
                AccountMeta::new_readonly(accounts.data_account_4, false);

            self.accounts.data_account_5 =
                AccountMeta::new_readonly(accounts.data_account_5, false);

            self.accounts.data_account_6 =
                AccountMeta::new_readonly(accounts.data_account_6, false);

            self.accounts
                .composite_account
                .set_from_accounts(accounts.composite_account);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.accounts.composite_account_nested.to_account_metas());

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.data_account_1.clone());

            metas.push(self.accounts.data_account_2.clone());

            metas.push(self.accounts.data_account_3.clone());

            metas.push(self.accounts.data_account_4.clone());

            metas.push(self.accounts.data_account_5.clone());

            metas.push(self.accounts.data_account_6.clone());

            metas.extend(self.accounts.composite_account.to_account_metas());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(Self::program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------

    /// Composite Account: composite_account_nested
    #[derive(Debug, Clone, Default)]
    pub struct CompositeAccountNestedInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub nested_inner: NestedInnerInstructionAccountMetas,
    }

    impl CompositeAccountNestedInstructionAccountMetas {
        pub fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.extend(self.nested_inner.to_account_metas());

            metas
        }

        pub fn set_from_accounts(&mut self, accounts: CompositeAccountNestedInstructionAccounts) {
            self.some_account = AccountMeta::new(accounts.some_account, false);

            self.nested_inner.set_from_accounts(accounts.nested_inner);
        }
    }

    #[derive(Debug, Clone)]
    pub struct CompositeAccountNestedInstructionAccounts {
        pub some_account: Pubkey,

        pub nested_inner: NestedInnerInstructionAccounts,
    }

    #[derive(Debug, Clone, Default)]
    pub struct NestedInnerInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    impl NestedInnerInstructionAccountMetas {
        pub fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.push(self.system_program.clone());

            metas
        }

        pub fn set_from_accounts(&mut self, accounts: NestedInnerInstructionAccounts) {
            self.some_account = AccountMeta::new_readonly(accounts.some_account, false);
        }
    }

    #[derive(Debug, Clone)]
    pub struct NestedInnerInstructionAccounts {
        pub some_account: Pubkey,
    }

    /// Composite Account: composite_account
    #[derive(Debug, Clone, Default)]
    pub struct CompositeAccountInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,
    }

    impl CompositeAccountInstructionAccountMetas {
        pub fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.push(self.signer.clone());

            metas.push(self.data_account_1.clone());

            metas
        }

        pub fn set_from_accounts(&mut self, accounts: CompositeAccountInstructionAccounts) {
            self.some_account = AccountMeta::new_readonly(accounts.some_account, false);

            self.signer = AccountMeta::new(accounts.signer, true);

            self.data_account_1 = AccountMeta::new_readonly(accounts.data_account_1, false);
        }
    }

    #[derive(Debug, Clone)]
    pub struct CompositeAccountInstructionAccounts {
        pub some_account: Pubkey,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,
    }
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: ClassicStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct ClassicStruct {
    pub field1: u8,

    pub field2: u16,

    pub field3: TridentPubkey,
}

/// Custom struct: ClassicStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct ClassicStructAccount {
    pub field1: u8,

    pub field2: u16,

    pub field3: TridentPubkey,
}

/// Custom struct: DataAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct DataAccount {
    pub unit_struct: UnitStruct,

    pub tuple_struct: TupleStruct,

    pub classic_struct: ClassicStruct,

    pub generic_struct: GenericStruct,

    pub optional_fields: OptionalFields,

    pub default_struct: DefaultStruct,

    pub nested_struct: NestedStruct,

    pub simple_enum: SimpleEnum,

    pub data_enum: DataEnum,

    pub multi_data_enum: MultiDataEnum,

    pub named_fields_enum: NamedFieldsEnum,

    pub generic_enum: GenericEnum,

    pub unit_variants: UnitVariants,
}

/// Custom enum: DataEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum DataEnum {
    Integer(i32),

    Float(f64),

    Text(String),

    Pubkey(TridentPubkey),
}

/// Custom struct: DefaultStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct DefaultStruct {
    pub field1: u8,

    pub field2: u16,

    pub field3: TridentPubkey,
}

/// Custom enum: GenericEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum GenericEnum {
    Value(T),

    None,
}

/// Custom struct: GenericStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct GenericStruct {
    pub value: T,

    pub key: TridentPubkey,
}

/// Custom enum: MultiDataEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum MultiDataEnum {
    Pair(i32, i32),

    Triple(i32, i32, i32),

    Pubkey(TridentPubkey, TridentPubkey),
}

/// Custom enum: NamedFieldsEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum NamedFieldsEnum {
    Point {
        x: f64,

        y: f64,
    },

    Circle {
        radius: f64,
    },

    Pubkey {
        pubkey1: TridentPubkey,

        pubkey2: TridentPubkey,
    },
}

/// Custom struct: NestedStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct NestedStruct {
    pub inner: ClassicStruct,

    pub key: TridentPubkey,
}

/// Custom struct: NestedStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct NestedStructAccount {
    pub inner: ClassicStructAccount,
}

/// Custom struct: OptionalFields
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct OptionalFields {
    pub field1: Option<u8>,

    pub field2: Option<u16>,

    pub field3: Option<TridentPubkey>,
}

/// Custom struct: OptionalFieldsAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct OptionalFieldsAccount {
    pub field1: Option<u8>,

    pub field2: Option<u16>,

    pub field3: Option<TridentPubkey>,
}

/// Custom enum: SimpleEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum SimpleEnum {
    Variant1,

    Variant2,

    Pubkey,
}

/// Custom struct: TupleStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TupleStruct {
    pub field_0: u8,

    pub field_1: u16,

    pub field_2: TridentPubkey,
}

/// Custom struct: TupleStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TupleStructAccount {
    pub field_0: u8,

    pub field_1: u16,

    pub field_2: TridentPubkey,
}

/// Custom struct: UnitStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UnitStruct {}

/// Custom struct: UnitStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UnitStructAccount {}

/// Custom enum: UnitVariants
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum UnitVariants {
    VariantA,

    VariantB,

    VariantC,
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
