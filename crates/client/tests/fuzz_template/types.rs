//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: additional_program
// ----------------------------------------------------------------------------
pub mod additional_program {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for additional_program
    pub fn program_id() -> Pubkey {
        pubkey!("8bPSKGoWCdAW8Hu3S1hLHPpBv8BNwse4jDyaXNrj3jWB")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {}

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {}

    impl InitializeInstructionAccounts {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {}

    impl InitializeInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------
// Program: idl_test
// ----------------------------------------------------------------------------
pub mod idl_test {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for idl_test
    pub fn program_id() -> Pubkey {
        pubkey!("HtD1eaPZ1JqtxcirNtYt3aAhUMoJWZ2Ddtzu4NDZCrhN")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: ProcessCustomTypes
    // ....................................................................

    /// Main instruction struct for ProcessCustomTypes
    pub struct ProcessCustomTypesInstruction {
        pub accounts: ProcessCustomTypesInstructionAccountMetas,
        pub data: ProcessCustomTypesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ProcessCustomTypes instruction
    #[derive(Debug, Clone, Default)]
    pub struct ProcessCustomTypesInstructionAccountMetas {
        pub composite_account_nested: CompositeAccountNestedInstructionAccountMetas,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,

        pub data_account_2: AccountMeta,

        pub data_account_3: AccountMeta,

        pub data_account_4: AccountMeta,

        pub data_account_5: AccountMeta,

        pub data_account_6: AccountMeta,

        pub composite_account: CompositeAccountInstructionAccountMetas,
    }

    /// Account pubkeys for ProcessCustomTypes instruction
    #[derive(Debug, Clone)]
    pub struct ProcessCustomTypesInstructionAccounts {
        pub composite_account_nested: CompositeAccountNestedInstructionAccounts,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,

        pub data_account_2: Pubkey,

        pub data_account_3: Pubkey,

        pub data_account_4: Pubkey,

        pub data_account_5: Pubkey,

        pub data_account_6: Pubkey,

        pub composite_account: CompositeAccountInstructionAccounts,
    }

    impl ProcessCustomTypesInstructionAccounts {
        pub fn new(
            composite_account_nested: CompositeAccountNestedInstructionAccounts,

            signer: Pubkey,

            data_account_1: Pubkey,

            data_account_2: Pubkey,

            data_account_3: Pubkey,

            data_account_4: Pubkey,

            data_account_5: Pubkey,

            data_account_6: Pubkey,

            composite_account: CompositeAccountInstructionAccounts,
        ) -> Self {
            Self {
                composite_account_nested,

                signer,

                data_account_1,

                data_account_2,

                data_account_3,

                data_account_4,

                data_account_5,

                data_account_6,

                composite_account,
            }
        }
    }

    /// Instruction data for ProcessCustomTypes
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ProcessCustomTypesInstructionData {
        pub _input_classic: ClassicStruct,

        pub _input_optional: OptionalFields,

        pub _input_tuple: TupleStruct,

        pub _input_enum: SimpleEnum,

        pub _input_data_enum: DataEnum,

        pub _input_multi_data_enum: MultiDataEnum,

        pub _input_named_fields_enum: NamedFieldsEnum,

        pub _input_generic_enum: GenericEnum,

        pub _input_unit_variants: UnitVariants,

        pub _input_nested: NestedStruct,

        pub _input_default: DefaultStruct,

        pub _input_generic_struct: GenericStruct,
    }

    impl ProcessCustomTypesInstructionData {
        pub fn new(
            _input_classic: ClassicStruct,

            _input_optional: OptionalFields,

            _input_tuple: TupleStruct,

            _input_enum: SimpleEnum,

            _input_data_enum: DataEnum,

            _input_multi_data_enum: MultiDataEnum,

            _input_named_fields_enum: NamedFieldsEnum,

            _input_generic_enum: GenericEnum,

            _input_unit_variants: UnitVariants,

            _input_nested: NestedStruct,

            _input_default: DefaultStruct,

            _input_generic_struct: GenericStruct,
        ) -> Self {
            Self {
                _input_classic,

                _input_optional,

                _input_tuple,

                _input_enum,

                _input_data_enum,

                _input_multi_data_enum,

                _input_named_fields_enum,

                _input_generic_enum,

                _input_unit_variants,

                _input_nested,

                _input_default,

                _input_generic_struct,
            }
        }
    }

    /// Implementation for ProcessCustomTypesInstruction
    impl ProcessCustomTypesInstruction {
        fn discriminator() -> [u8; 8] {
            [37u8, 23u8, 242u8, 88u8, 134u8, 197u8, 190u8, 108u8]
        }

        pub fn data(data: ProcessCustomTypesInstructionData) -> Self {
            Self {
                accounts: ProcessCustomTypesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ProcessCustomTypesInstructionAccounts) -> Self {
            self.accounts
                .composite_account_nested
                .set_from_accounts(accounts.composite_account_nested);

            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.data_account_1 =
                AccountMeta::new_readonly(accounts.data_account_1, false);

            self.accounts.data_account_2 =
                AccountMeta::new_readonly(accounts.data_account_2, false);

            self.accounts.data_account_3 =
                AccountMeta::new_readonly(accounts.data_account_3, false);

            self.accounts.data_account_4 =
                AccountMeta::new_readonly(accounts.data_account_4, false);

            self.accounts.data_account_5 =
                AccountMeta::new_readonly(accounts.data_account_5, false);

            self.accounts.data_account_6 =
                AccountMeta::new_readonly(accounts.data_account_6, false);

            self.accounts
                .composite_account
                .set_from_accounts(accounts.composite_account);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.accounts.composite_account_nested.to_account_metas());

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.data_account_1.clone());

            metas.push(self.accounts.data_account_2.clone());

            metas.push(self.accounts.data_account_3.clone());

            metas.push(self.accounts.data_account_4.clone());

            metas.push(self.accounts.data_account_5.clone());

            metas.push(self.accounts.data_account_6.clone());

            metas.extend(self.accounts.composite_account.to_account_metas());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ProcessRustTypes
    // ....................................................................

    /// Main instruction struct for ProcessRustTypes
    pub struct ProcessRustTypesInstruction {
        pub accounts: ProcessRustTypesInstructionAccountMetas,
        pub data: ProcessRustTypesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ProcessRustTypes instruction
    #[derive(Debug, Clone, Default)]
    pub struct ProcessRustTypesInstructionAccountMetas {
        pub composite_account_nested: CompositeAccountNestedInstructionAccountMetas,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,

        pub data_account_2: AccountMeta,

        pub data_account_3: AccountMeta,

        pub data_account_4: AccountMeta,

        pub data_account_5: AccountMeta,

        pub data_account_6: AccountMeta,

        pub composite_account: CompositeAccountInstructionAccountMetas,
    }

    /// Account pubkeys for ProcessRustTypes instruction
    #[derive(Debug, Clone)]
    pub struct ProcessRustTypesInstructionAccounts {
        pub composite_account_nested: CompositeAccountNestedInstructionAccounts,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,

        pub data_account_2: Pubkey,

        pub data_account_3: Pubkey,

        pub data_account_4: Pubkey,

        pub data_account_5: Pubkey,

        pub data_account_6: Pubkey,

        pub composite_account: CompositeAccountInstructionAccounts,
    }

    impl ProcessRustTypesInstructionAccounts {
        pub fn new(
            composite_account_nested: CompositeAccountNestedInstructionAccounts,

            signer: Pubkey,

            data_account_1: Pubkey,

            data_account_2: Pubkey,

            data_account_3: Pubkey,

            data_account_4: Pubkey,

            data_account_5: Pubkey,

            data_account_6: Pubkey,

            composite_account: CompositeAccountInstructionAccounts,
        ) -> Self {
            Self {
                composite_account_nested,

                signer,

                data_account_1,

                data_account_2,

                data_account_3,

                data_account_4,

                data_account_5,

                data_account_6,

                composite_account,
            }
        }
    }

    /// Instruction data for ProcessRustTypes
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ProcessRustTypesInstructionData {
        pub _input_u8: u8,

        pub _input_u16: u16,

        pub _input_u32: u32,

        pub _input_u64: u64,

        pub _input_i8: i8,

        pub _input_i16: i16,

        pub _input_i32: i32,

        pub _input_i64: i64,

        pub _input_i128: i128,

        pub _input_f32: f32,

        pub _input_f64: f64,

        pub _input_string: String,

        pub _input_vec: Vec<u8>,

        pub _input_vec_string: Vec<String>,

        pub _input_bool: bool,
    }

    impl ProcessRustTypesInstructionData {
        pub fn new(
            _input_u8: u8,

            _input_u16: u16,

            _input_u32: u32,

            _input_u64: u64,

            _input_i8: i8,

            _input_i16: i16,

            _input_i32: i32,

            _input_i64: i64,

            _input_i128: i128,

            _input_f32: f32,

            _input_f64: f64,

            _input_string: String,

            _input_vec: Vec<u8>,

            _input_vec_string: Vec<String>,

            _input_bool: bool,
        ) -> Self {
            Self {
                _input_u8,

                _input_u16,

                _input_u32,

                _input_u64,

                _input_i8,

                _input_i16,

                _input_i32,

                _input_i64,

                _input_i128,

                _input_f32,

                _input_f64,

                _input_string,

                _input_vec,

                _input_vec_string,

                _input_bool,
            }
        }
    }

    /// Implementation for ProcessRustTypesInstruction
    impl ProcessRustTypesInstruction {
        fn discriminator() -> [u8; 8] {
            [74u8, 102u8, 18u8, 245u8, 253u8, 10u8, 252u8, 246u8]
        }

        pub fn data(data: ProcessRustTypesInstructionData) -> Self {
            Self {
                accounts: ProcessRustTypesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ProcessRustTypesInstructionAccounts) -> Self {
            self.accounts
                .composite_account_nested
                .set_from_accounts(accounts.composite_account_nested);

            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.data_account_1 =
                AccountMeta::new_readonly(accounts.data_account_1, false);

            self.accounts.data_account_2 =
                AccountMeta::new_readonly(accounts.data_account_2, false);

            self.accounts.data_account_3 =
                AccountMeta::new_readonly(accounts.data_account_3, false);

            self.accounts.data_account_4 =
                AccountMeta::new_readonly(accounts.data_account_4, false);

            self.accounts.data_account_5 =
                AccountMeta::new_readonly(accounts.data_account_5, false);

            self.accounts.data_account_6 =
                AccountMeta::new_readonly(accounts.data_account_6, false);

            self.accounts
                .composite_account
                .set_from_accounts(accounts.composite_account);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.extend(self.accounts.composite_account_nested.to_account_metas());

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.data_account_1.clone());

            metas.push(self.accounts.data_account_2.clone());

            metas.push(self.accounts.data_account_3.clone());

            metas.push(self.accounts.data_account_4.clone());

            metas.push(self.accounts.data_account_5.clone());

            metas.push(self.accounts.data_account_6.clone());

            metas.extend(self.accounts.composite_account.to_account_metas());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------

    /// Composite Account: composite_account_nested
    #[derive(Debug, Clone, Default)]
    pub struct CompositeAccountNestedInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub nested_inner: NestedInnerInstructionAccountMetas,
    }

    impl CompositeAccountNestedInstructionAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.extend(self.nested_inner.to_account_metas());

            metas
        }

        fn set_from_accounts(&mut self, accounts: CompositeAccountNestedInstructionAccounts) {
            self.some_account = AccountMeta::new(accounts.some_account, false);

            self.nested_inner.set_from_accounts(accounts.nested_inner);
        }
    }

    #[derive(Debug, Clone)]
    pub struct CompositeAccountNestedInstructionAccounts {
        pub some_account: Pubkey,

        pub nested_inner: NestedInnerInstructionAccounts,
    }

    impl CompositeAccountNestedInstructionAccounts {
        pub fn new(some_account: Pubkey, nested_inner: NestedInnerInstructionAccounts) -> Self {
            Self {
                some_account,

                nested_inner,
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct NestedInnerInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub system_program: AccountMeta,
    }

    impl NestedInnerInstructionAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.push(self.system_program.clone());

            metas
        }

        fn set_from_accounts(&mut self, accounts: NestedInnerInstructionAccounts) {
            self.some_account = AccountMeta::new_readonly(accounts.some_account, false);
        }
    }

    #[derive(Debug, Clone)]
    pub struct NestedInnerInstructionAccounts {
        pub some_account: Pubkey,
    }

    impl NestedInnerInstructionAccounts {
        pub fn new(some_account: Pubkey) -> Self {
            Self { some_account }
        }
    }

    /// Composite Account: composite_account
    #[derive(Debug, Clone, Default)]
    pub struct CompositeAccountInstructionAccountMetas {
        pub some_account: AccountMeta,

        pub signer: AccountMeta,

        pub data_account_1: AccountMeta,
    }

    impl CompositeAccountInstructionAccountMetas {
        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.some_account.clone());

            metas.push(self.signer.clone());

            metas.push(self.data_account_1.clone());

            metas
        }

        fn set_from_accounts(&mut self, accounts: CompositeAccountInstructionAccounts) {
            self.some_account = AccountMeta::new_readonly(accounts.some_account, false);

            self.signer = AccountMeta::new(accounts.signer, true);

            self.data_account_1 = AccountMeta::new_readonly(accounts.data_account_1, false);
        }
    }

    #[derive(Debug, Clone)]
    pub struct CompositeAccountInstructionAccounts {
        pub some_account: Pubkey,

        pub signer: Pubkey,

        pub data_account_1: Pubkey,
    }

    impl CompositeAccountInstructionAccounts {
        pub fn new(some_account: Pubkey, signer: Pubkey, data_account_1: Pubkey) -> Self {
            Self {
                some_account,

                signer,

                data_account_1,
            }
        }
    }
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: ClassicStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct ClassicStruct {
    pub field1: u8,

    pub field2: u16,

    pub field3: Pubkey,
}

impl ClassicStruct {
    pub fn new(field1: u8, field2: u16, field3: Pubkey) -> Self {
        Self {
            field1,

            field2,

            field3,
        }
    }
}

/// Custom struct: ClassicStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct ClassicStructAccount {
    pub field1: u8,

    pub field2: u16,

    pub field3: Pubkey,
}

impl ClassicStructAccount {
    pub fn new(field1: u8, field2: u16, field3: Pubkey) -> Self {
        Self {
            field1,

            field2,

            field3,
        }
    }
}

/// Custom struct: DataAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct DataAccount {
    pub unit_struct: UnitStruct,

    pub tuple_struct: TupleStruct,

    pub classic_struct: ClassicStruct,

    pub generic_struct: GenericStruct,

    pub optional_fields: OptionalFields,

    pub default_struct: DefaultStruct,

    pub nested_struct: NestedStruct,

    pub simple_enum: SimpleEnum,

    pub data_enum: DataEnum,

    pub multi_data_enum: MultiDataEnum,

    pub named_fields_enum: NamedFieldsEnum,

    pub generic_enum: GenericEnum,

    pub unit_variants: UnitVariants,
}

impl DataAccount {
    pub fn new(
        unit_struct: UnitStruct,

        tuple_struct: TupleStruct,

        classic_struct: ClassicStruct,

        generic_struct: GenericStruct,

        optional_fields: OptionalFields,

        default_struct: DefaultStruct,

        nested_struct: NestedStruct,

        simple_enum: SimpleEnum,

        data_enum: DataEnum,

        multi_data_enum: MultiDataEnum,

        named_fields_enum: NamedFieldsEnum,

        generic_enum: GenericEnum,

        unit_variants: UnitVariants,
    ) -> Self {
        Self {
            unit_struct,

            tuple_struct,

            classic_struct,

            generic_struct,

            optional_fields,

            default_struct,

            nested_struct,

            simple_enum,

            data_enum,

            multi_data_enum,

            named_fields_enum,

            generic_enum,

            unit_variants,
        }
    }
}

/// Custom enum: DataEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum DataEnum {
    Integer(i32),

    Float(f64),

    Text(String),

    Pubkey(Pubkey),
}

/// Custom struct: DefaultStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct DefaultStruct {
    pub field1: u8,

    pub field2: u16,

    pub field3: Pubkey,
}

impl DefaultStruct {
    pub fn new(field1: u8, field2: u16, field3: Pubkey) -> Self {
        Self {
            field1,

            field2,

            field3,
        }
    }
}

/// Custom enum: GenericEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum GenericEnum {
    Value(T),

    None,
}

/// Custom struct: GenericStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct GenericStruct {
    pub value: T,

    pub key: Pubkey,
}

impl GenericStruct {
    pub fn new(value: T, key: Pubkey) -> Self {
        Self { value, key }
    }
}

/// Custom enum: MultiDataEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum MultiDataEnum {
    Pair(i32, i32),

    Triple(i32, i32, i32),

    Pubkey(Pubkey, Pubkey),
}

/// Custom enum: NamedFieldsEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum NamedFieldsEnum {
    Point { x: f64, y: f64 },

    Circle { radius: f64 },

    Pubkey { pubkey1: Pubkey, pubkey2: Pubkey },
}

/// Custom struct: NestedStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct NestedStruct {
    pub inner: ClassicStruct,

    pub key: Pubkey,
}

impl NestedStruct {
    pub fn new(inner: ClassicStruct, key: Pubkey) -> Self {
        Self { inner, key }
    }
}

/// Custom struct: NestedStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct NestedStructAccount {
    pub inner: ClassicStructAccount,
}

impl NestedStructAccount {
    pub fn new(inner: ClassicStructAccount) -> Self {
        Self { inner }
    }
}

/// Custom struct: OptionalFields
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct OptionalFields {
    pub field1: Option<u8>,

    pub field2: Option<u16>,

    pub field3: Option<Pubkey>,
}

impl OptionalFields {
    pub fn new(field1: Option<u8>, field2: Option<u16>, field3: Option<Pubkey>) -> Self {
        Self {
            field1,

            field2,

            field3,
        }
    }
}

/// Custom struct: OptionalFieldsAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct OptionalFieldsAccount {
    pub field1: Option<u8>,

    pub field2: Option<u16>,

    pub field3: Option<Pubkey>,
}

impl OptionalFieldsAccount {
    pub fn new(field1: Option<u8>, field2: Option<u16>, field3: Option<Pubkey>) -> Self {
        Self {
            field1,

            field2,

            field3,
        }
    }
}

/// Custom enum: SimpleEnum
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum SimpleEnum {
    Variant1,

    Variant2,

    Pubkey,
}

/// Custom struct: TupleStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TupleStruct {
    pub field_0: u8,

    pub field_1: u16,

    pub field_2: Pubkey,
}

impl TupleStruct {
    pub fn new(field_0: u8, field_1: u16, field_2: Pubkey) -> Self {
        Self {
            field_0,

            field_1,

            field_2,
        }
    }
}

/// Custom struct: TupleStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TupleStructAccount {
    pub field_0: u8,

    pub field_1: u16,

    pub field_2: Pubkey,
}

impl TupleStructAccount {
    pub fn new(field_0: u8, field_1: u16, field_2: Pubkey) -> Self {
        Self {
            field_0,

            field_1,

            field_2,
        }
    }
}

/// Custom struct: UnitStruct
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UnitStruct {}

/// Custom struct: UnitStructAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct UnitStructAccount {}

/// Custom enum: UnitVariants
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum UnitVariants {
    VariantA,

    VariantB,

    VariantC,
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
