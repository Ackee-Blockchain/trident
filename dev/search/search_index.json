{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trident","text":"<p>Trident is a Rust-based framework to fuzz and integration test Solana programs to help you ship secure code.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Automated Test Generation: Simplifies the testing process by automatically creating templates for fuzz and integration tests for programs written using the Anchor Framework.</p> </li> <li> <p>Dynamic Data Generation: Increases test coverage with random instruction data and pseudo-random accounts for unpredictable fuzz test scenarios.</p> </li> <li> <p>Custom Instruction Sequences: Provides the flexibility to design specific sequences of instructions to meet particular testing needs or to focus on particular aspects of program behavior during fuzz testing. Invariant Checks: Allows for custom invariants checks to spot vulnerabilities and unwanted behaviors.</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning (SemVer).</p> <p>Note: Version 0 of Semantic Versioning is handled differently from version 1 and above. The minor version will be incremented upon a breaking change and the patch version will be incremented for features.</p>"},{"location":"CHANGELOG/#dev-unreleased","title":"[dev] - Unreleased","text":""},{"location":"CHANGELOG/#070-2024-08-14","title":"[0.7.0] - 2024-08-14","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>impr/ add feature flag to the AccountsSnapshots macro (183)</li> <li>feat/ add Support for CPI (182)</li> <li>feat/ add option to initialize Trident with Macro/File (for Snapshots) option based on preference (179)</li> <li>feat/create AccountsSnapshots derive macro for Snapshots creation (#177)</li> <li>feat/fuzzing moved to separate crate trident-fuzz (#175)</li> <li>feat/unify dependencies provided by the Trident (#172)</li> <li>feat/fuzzer-stats-logging, an optional statistics output for fuzzing session (#144)</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>fix/in case of fuzzing failure throw error instead of only printing message (#167)</li> <li>fix/snapshot's zeroed account as optional (#170)</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>del/remove localnet subcommand (178)</li> <li>del/remove unnecessary fuzzing feature as trident is mainly fuzzer (#176)</li> <li>del/remove Trident explorer (#171)</li> </ul>"},{"location":"CHANGELOG/#060-2024-05-20","title":"[0.6.0] - 2024-05-20","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>feat/anchor 0.30.0 support (#148)</li> <li>fix/allow to process duplicate transactions (#147)</li> <li>feat/possibility to implement custom transaction error handling (#145)</li> <li>feat/support of automatically obtaining fully qualified paths of Data Accounts Custom types for <code>accounts_snapshots.rs</code> (#141)</li> <li>feat/allow direct accounts manipulation and storage (#142)</li> <li>feat/support of non-corresponding instruction and context names (#130)</li> <li>feat/refactored and improved program flow during init and build, added activity indicator (#129)</li> <li>feat/allow solana versions up to v1.17.* and pin Rust 1.77 nightly compiler (#128)</li> <li>feat/new init command option to initialize fuzz or poc tests only (#124)</li> <li>feat/debug-mode detailed output (#125)</li> <li>feat/anchor 0.29.0 support (#121)</li> <li>doc/add help comment + update documentation (#120)</li> <li>feat/fuzzer error handling (#118)</li> <li>feat/convert fuzz Pubkey to AccountId (#116)</li> <li>feat/additional anchor types (#115)</li> <li>feat/import ToAccountInfo trait in fuzzing prelude (#113)</li> <li>test/added code generation and macros tests (#112)</li> <li>feat/fuzzer framework core, macros, helpers, templates, and examples. (#111)</li> <li>feat/improved trident-tests folder structure for PoC and Fuzz Tests (#109)</li> <li>feat/support for additional fuzzer parameters in Trident.toml config file (#107)</li> <li>feat/posibility to pass params to the fuzzer via Trident.toml config file (#106)</li> <li>feat/client now reads by default keypair from default location (#105)</li> <li>feat/added new --exit-code option to return corresponding exit code based on fuzz test result (#104)</li> <li>feat/removed/updated deprecated functions, removed allow deprecated macros (#103)</li> <li>feat/added new function to read keypair file generated by Anchor (#102)</li> <li>feat/clean command (#101)</li> <li>feat/improved program_client generated code (#100)</li> <li>feat/automatically add hfuzz_target to .gitignore file (#99)</li> <li>feat/support for dynamic templates. (#98)</li> </ul>"},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>fix/refactored fuzz test executor error handling (#127)</li> <li>fix/warn user on composite accounts and continue fuzz test generation (#133)</li> <li>fix/progress bar loop lock release (#132)</li> <li>fix/fixed fuzz test generation with init-if-needed Anchor feature (#131)</li> <li>fix/program client custom types (#117)</li> <li>fix/check fuzz test name collision by checking the name against HashSet (#114)</li> </ul>"},{"location":"CHANGELOG/#050-2023-08-28","title":"[0.5.0] - 2023-08-28","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>cli: Added trident subcommand <code>fuzz</code> to run and debug fuzz tests using honggfuzz-rs.</li> <li>cli: Added trident <code>--skip-fuzzer</code> option for <code>init</code> subcommand to skip generation of fuzz test templates.</li> <li>client: Added new Cargo feature <code>fuzzing</code> that enables optional dependencies related to fuzz testing.</li> </ul>"},{"location":"CHANGELOG/#041-2023-08-21","title":"[0.4.1] - 2023-08-21","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Upgrade Solana (<code>=1.16.6</code>) and Anchor framework (<code>=0.28.0</code>) versions.</li> </ul>"},{"location":"CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Implemented Anchor Client logic was not able to work with newer version of Anchor. Fixed with <code>async_rpc</code> and <code>async</code> feature.</li> <li>Trident init IDL Parse Error on newer version of Rust, fixed with updated <code>accounts</code> token.</li> </ul>"},{"location":"CHANGELOG/#030-2022-09-23","title":"[0.3.0] - 2022-09-23","text":""},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Upgrade Solana (<code>~1.10</code>) and Anchor framework (<code>~0.25</code>) versions</li> </ul>"},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Custom Solana RPC error reporter. If the Solana RPC error is thrown, the error code, message and data (logs) are reported to the output.</li> <li>Custom imports in the <code>.program_client</code>. User is able to import custom types and structures into program client. The import part of the code would not be re-generated.</li> </ul>"},{"location":"CHANGELOG/#020-2022-07-27","title":"[0.2.0] - 2022-07-27","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Trident is now configurable. This requires <code>Trident.toml</code> file to exist in the project's root directory - without this file the execution will fail. To solve this re-run <code>trident init</code> or just create an empty <code>Trident.toml</code> file in the project's root directory.</li> </ul>"},{"location":"fuzzing/fuzzing-current-limitations/","title":"Current limitations","text":"<p>This section summarizes some known limitations in the current development stage. Further development will be focused on resolving these limitations.</p> <ul> <li>Only fuzzing of one program without CPIs to other custom programs is supported.</li> <li>Remaining accounts in check methods are not supported.</li> <li>Composite accounts are not supported (however it is possible to generate a fuzz test and finish the composite accounts deserialization manually).</li> </ul>"},{"location":"fuzzing/fuzzing-examples/","title":"Fuzzing Examples","text":""},{"location":"fuzzing/fuzzing-examples/#hello-world-example","title":"Hello World! Example","text":"<ul> <li>hello_world</li> </ul>"},{"location":"fuzzing/fuzzing-examples/#possible-vulnerabilities-and-bugs","title":"Possible vulnerabilities and bugs","text":"<ul> <li>unchecked-arithmetic-0</li> <li>incorrect-ix-sequence-1</li> <li>unauthorized-access-2</li> <li>incorrect-integer-arithmetic-3</li> </ul>"},{"location":"fuzzing/fuzzing-examples/#example-usage-of-arbitrary-trait-with-custom-data-type-as-instruction-parameter","title":"Example usage of Arbitrary Trait with Custom Data type as Instruction parameter","text":"<ul> <li>arbitrary-custom-types-4</li> </ul>"},{"location":"fuzzing/fuzzing-examples/#example-usage-of-limiting-the-instruction-data-structure-with-the-arbitrary-trait","title":"Example usage of limiting the Instruction data structure with the Arbitrary trait","text":"<ul> <li>arbitrary-limit-inputs-5</li> </ul>"},{"location":"fuzzing/fuzzing-introduction/","title":"Introduction","text":"<p>Fuzzing is a software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program. The aim is to uncover bugs and vulnerabilities that might not be detected with conventional testing strategies.</p>"},{"location":"fuzzing/fuzzing-introduction/#trident","title":"Trident","text":"<p>The <code>Trident</code> testing framework equips developers with tools to efficiently develop fuzz tests for Anchor-based programs. It streamlines the fuzz testing process through automation and comprehensive support:</p> <ul> <li>Automatically parses Anchor-based programs to generate necessary implementations for deserializing instruction accounts.</li> <li>Generates templates for developers to customize according to the specific needs of their fuzz test scenarios.</li> <li>Offers derive macros to effortlessly implement required traits, reducing manual coding efforts.</li> <li>Includes a bank client and helper functions for simplified account management during testing.</li> <li>Provides a Command-Line Interface (CLI) for executing and debugging fuzz tests with ease.</li> </ul> <p><code>Trident</code> is built for customization, enabling developers to tailor their fuzz tests by adjusting:</p> <ul> <li>Execution Order of Instructions: Test different sequences and their effects on the program to uncover sequence-related vulnerabilities.</li> <li>Instruction Parameters: Identify how variations in inputs influence program behavior, testing for robustness against a wide range of data.</li> <li>Instruction Accounts: Explore the impact of different account states on the software's functionality, ensuring comprehensive account testing.</li> <li>Comprehensive Testing: Conduct thorough and effective fuzz testing by combining any of the above aspects.</li> </ul> <p>This framework supports a detailed and methodical approach to fuzz testing, facilitating the identification and remediation of potential vulnerabilities in software applications.</p>"},{"location":"fuzzing/fuzzing-lifecycle/","title":"Fuzz Test Lifecycle","text":"<p>In the sequence diagram below you can see a simplified fuzz test lifecycle.</p> <p>Some diagram states are labeled with emojis:</p> <ul> <li>\u26a1 Mandatory methods that must be implemented by the user.</li> <li>\ud83d\udc64 Optional methods that can be implemented by the user.</li> </ul>"},{"location":"fuzzing/fuzzing-lifecycle/#lifecycle","title":"Lifecycle","text":"<ol> <li>The fuzzer is running until:<ol> <li>The maximal number of iterations is reached (if specified).</li> <li>A crash was detected and the <code>exit_upon_crash</code> parameter was set.</li> <li>User interrupted the test manually (for example by hitting <code>CTRL+C</code>).</li> </ol> </li> <li>In each iteration, the fuzzer generates a sequence of random instructions to execute.<ol> <li>User can optionally customize how the instructions are generated and can specify the instructions that should be executed at the beginning (<code>pre_ixs</code>), in the middle (<code>ixs</code>) and at the end (<code>post_ixs</code>) of each iteration. This can be useful for example if your program needs an initialization or you want to fuzz some specific program state.</li> </ol> </li> <li>For each instruction:<ol> <li>User defined mandatory method <code>get_accounts()</code> is called to collect necessary instruction accounts.</li> <li>User defined mandatory method <code>get_data()</code> is called to collect instruction data.</li> <li>A snapshot of all instruction accounts before the instruction execution is saved.</li> <li>The instruction is executed.</li> <li>A snapshot of all instruction accounts after the instruction execution is saved.</li> <li>User defined optional method <code>check()</code> is called to check accounts data and evaluate invariants.</li> </ol> </li> </ol> fuzzer_iterations = 0fuzzer_iterations = 0fuzzer_iterations &lt;\u00a0max_iterationsfuzzer_iterations &lt;...donedonecreate pre-instruction\u00a0accounts snapshotscreate pre-instruction...execute instructionexecute instructioncreate post-instruction\u00a0accounts snapshotscreate post-instruction...check invariants \ud83d\udc64check invariants \ud83d\udc64fuzzer_iterations++fuzzer_iterations++Generate instructionspre_ixs \ud83d\udc64pre_ixs \ud83d\udc64ixs \ud83d\udc64ixs \ud83d\udc64post_ixs \ud83d\udc64post_ixs \ud83d\udc64endendfor ix in instructionsfor ix in instructionsget instruction accounts \u26a1get instruction accounts \u26a1get instruction data \u26a1get instruction data \u26a1next ixnext ixText is not SVG - cannot display"},{"location":"fuzzing/fuzzing-run-debug/","title":"Run and Debug","text":""},{"location":"fuzzing/fuzzing-run-debug/#run","title":"Run","text":"<p>Once you have finished the implementation of the Fuzz Test, you can run the Test as follows:</p> <pre><code># Replace &lt;TARGET_NAME&gt; with the name of particular\n# fuzz test (for example: \"fuzz_0\")\ntrident fuzz run &lt;TARGET_NAME&gt;\n</code></pre> <p>Under the hood Trident uses honggfuzz-rs.</p> <p>You can pass supported parameters via the Trident.toml configuration file:</p> <pre><code># Content of Trident.toml\n[honggfuzz]\n# Timeout in seconds (default: 10)\ntimeout = 10\n# Number of fuzzing iterations (default: 0 [no limit])\niterations = 0\n# Number of concurrent fuzzing threads (default: 0 [number of CPUs / 2])\nthreads = 0\n# Don't close children's stdin, stdout, stderr; can be noisy (default: false)\nkeep_output = false\n# Disable ANSI console; use simple log output (default: false)\nverbose = false\n# Exit upon seeing the first crash (default: false)\nexit_upon_crash = false\n# Maximal number of mutations per one run (default: 6)\nmutations_per_run = 6\n# Target compilation directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_target\"]).\n# To not clash with cargo build's default target directory.\ncargo_target_dir = \"\"\n# Honggfuzz working directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_workspace\"]).\nhfuzz_workspace = \"\"\n# Directory where crashes are saved to (default: \"\" [workspace directory])\ncrashdir = \"\"\n# Input file extension (e.g. 'swf'), (default: \"\" ['fuzz'])\nextension = \"\"\n# Number of seconds this fuzzing session will last (default: 0 [no limit])\nrun_time = 0\n# Maximal size of files processed by the fuzzer in bytes (default: 1048576 = 1MB)\nmax_file_size = 1048576\n# Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames (default: false)\nsave_all = false\n\n[fuzz]\n# Allow processing of duplicate transactions. Setting to true might speed up fuzzing but can cause false positive crashes (default: false)\nallow_duplicate_txs = false\n# Trident will show statistics after the fuzzing session. This option forces use of honggfuzz parameter\n# `keep_output` as true in order to be able to catch fuzzer stdout. (default: false)\nfuzzing_with_stats = true\n</code></pre> <p>Or you can pass any parameter via environment variables.</p> <p>A list of hongfuzz parameters can be found in honggfuzz usage documentation. The parameters passed via environment variables have higher priority. For example:</p> <pre><code># Time-out: 10 secs\n# Number of concurrent fuzzing threads: 1\n# Number of fuzzing iterations: 10000\n# Display Solana logs in the terminal\nHFUZZ_RUN_ARGS=\"-t 10 -n 1 -N 10000 -Q\" trident fuzz run &lt;TARGET_NAME&gt;\n</code></pre>"},{"location":"fuzzing/fuzzing-run-debug/#fuzzing-statistics","title":"Fuzzing statistics","text":"<p>Sometimes, it's useful to know how often a particular instruction has been invoked and how many times it has succeeded or failed. To display these statistics when fuzzing is finished or interrupted, set the <code>fuzzing_with_stats</code> option to <code>true</code> in the <code>[fuzz]</code> section of the Trident.toml configuration file. Please note that this option is disabled by default because it impacts performance.</p> <p>The statistics show the total number of invocations for each instruction, which is the sum of successful and failed invocations. Successful invocations are those that return an <code>Ok()</code> result. Failed invocations are those that return an <code>Err()</code> result. Additionally, the statistics also show as <code>Check Failed</code> the number of successful invocations that did not pass the user-defined invariants check. Note that unhandled panics are currently logged only as crashes and are not displayed in the fuzzing statistics table.</p> <p>Keep in mind that the number of fuzz iterations does not directly correspond to the total number of invocations. In one fuzz iteration, the fuzzer might be unable to deserialize fuzz data into instructions, causing the entire iteration to be skipped.</p>"},{"location":"fuzzing/fuzzing-run-debug/#debug","title":"Debug","text":"<p>To debug your program with values from a crash file:</p> <pre><code># fuzzer will run the &lt;TARGET_NAME&gt; with the specified &lt;CRASH_FILE_PATH&gt;\ntrident fuzz run-debug &lt;TARGET_NAME&gt; &lt;CRASH_FILE_PATH&gt;\n# for example:\ntrident fuzz run-debug fuzz_0 trident-tests/fuzz_tests/fuzzing/fuzz_0/cr1.fuzz\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p0/","title":"First Steps","text":"<p>At the current development stage, there are some manual steps required to make your fuzz test compile:</p> <ol> <li>Add dependencies specific to your program to <code>trident-tests/fuzz_tests/Cargo.toml</code> (such as anchor-spl etc.).</li> <li>Add necessary <code>use</code> statements into <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/accounts_snapshots.rs</code> to import missing types.</li> </ol>"},{"location":"fuzzing/howto/fuzzing-howto-p1/","title":"Specify accounts to reuse","text":"<p>Trident fuzzer helps you to generate only a limited amount of pseudo-random accounts and reuse them in the instructions.</p> <p>Always generating only random accounts would in most cases lead to a situation where the fuzzer would be stuck because the accounts would be almost every time rejected by your Anchor program. Therefore it is necessary to specify, what accounts should be used and also limit the number of newly created accounts to reduce the space complexity.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>FuzzAccounts</code> structure. It contains all accounts used in your program. You have to determine if the account is a:<ul> <li>Signer</li> <li>PDA</li> <li>Token Account</li> <li>Program account</li> </ul> </li> </ul> <p>Then use the corresponding <code>AccountsStorage</code> types such as:</p> <pre><code>pub struct FuzzAccounts {\n    signer: AccountsStorage&lt;Keypair&gt;,\n    some_pda: AccountsStorage&lt;PdaStore&gt;,\n    token_vault: AccountsStorage&lt;TokenStore&gt;,\n    mint: AccountsStorage&lt;MintStore&gt;,\n}\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p2/","title":"Specify instruction data","text":"<p>Trident fuzzer generates random instruction data for you.</p> <p>Currently, it is however required, that you manually assign the random fuzzer data to the instruction data. It is done using the <code>IxOps</code> trait and its method <code>get_data</code>.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>get_data</code> methods for each instruction such as:</li> </ul> <pre><code>fn get_data(\n    &amp;self,\n    _client: &amp;mut impl FuzzClient,\n    _fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n    let data = fuzz_example1::instruction::Invest {\n        amount: self.data.amount,\n    };\n    Ok(data)\n}\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p3/","title":"Specify instruction accounts","text":"<p>Trident fuzzer generates random indexes of accounts to use in each instruction. Each created account is saved in the global <code>FuzzAccounts</code> structure which helps you to reuse already existing accounts across all instructions.</p> <p>You are required to define, how these accounts should be created and which accounts should be passed to an instruction. It is done using the <code>IxOps</code> trait and its method <code>get_accounts</code>.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>get_accounts</code> methods for each instruction such as:</li> </ul> <p><pre><code>fn get_accounts(\n    &amp;self,\n    client: &amp;mut impl FuzzClient,\n    fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;(Vec&lt;Keypair&gt;, Vec&lt;AccountMeta&gt;), FuzzingError&gt; {\n    let author = fuzz_accounts.author.get_or_create_account(\n        self.accounts.author,\n        client,\n        5000000000000,\n    );\n    let signers = vec![author.clone()];\n    let state = fuzz_accounts\n        .state\n        .get_or_create_account(\n            self.accounts.state,\n            &amp;[author.pubkey().as_ref(), STATE_SEED.as_ref()],\n            &amp;fuzz_example1::ID,\n        )\n        .ok_or(FuzzingError::CannotGetAccounts)?\n        .pubkey();\n    let acc_meta = fuzz_example1::accounts::EndRegistration {\n        author: author.pubkey(),\n        state,\n    }\n    .to_account_metas(None);\n    Ok((signers, acc_meta))\n}\n</code></pre> Notice especially the helper method <code>fuzz_accounts.&lt;account_name&gt;.get_or_create_account</code> that is used to create a Keypair or retrieve the Public key of the already existing account.</p>"},{"location":"fuzzing/howto/fuzzing-howto-p3/#create-an-arbitrary-account","title":"Create an arbitrary account","text":"<p>The <code>AccountsStorage&lt;T&gt;</code> type provides an implementation of the <code>get_or_create_account</code> method that helps you create new or read already existing accounts. There are different implementations for different types of storage (<code>Keypair</code>, <code>TokenStore</code>, <code>MintStore</code>, <code>PdaStore</code>) to simplify the creation of new accounts.</p> <p>However, there are cases when the provided implementation is not sufficient and it is necessary to create an account manually. These cases can be (but are not limited to) for example:</p> <ul> <li>you need to create a new account with a predefined address</li> <li>you need to create a new account that is not owned by the system program</li> <li>you need to create and initialize a new PDA account</li> <li>your program expects an account to be initialized in a previous instruction</li> </ul> <p>In that case, you can use the <code>storage</code> method of the <code>AccountsStorage&lt;T&gt;</code> struct that exposes the underlying <code>HashMap&lt;AccountId, T&gt;</code> and you can add new accounts directly to it.</p> <p>It is possible to create and store any kind of account. For example:</p> <ul> <li>to add an account that uses the <code>#[account(zero)]</code> anchor constraint (must be rent exempt, owned by your program, with empty data):</li> </ul> <pre><code>let state = fuzz_accounts\n    .state\n    // gets the storage of all `state` account variants\n    .storage()\n    // returns the Keypair of the `state` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.state)\n    .or_insert_with(|| {\n        let space = State::SIZE;\n        let rent_exempt_lamports = client.get_rent().unwrap()\n                            .minimum_balance(space);\n        let keypair = Keypair::new();\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_lamports,\n            &amp;[],\n            space,\n            &amp;my_program::id(),\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;keypair.pubkey(), &amp;account);\n        keypair\n    });\n</code></pre> <ul> <li>to add a new system-owned account with a specific PDA (address):</li> </ul> <pre><code>let rent_exempt_for_token_acc = client\n    .get_rent()\n    .unwrap()\n    .minimum_balance(anchor_spl::token::spl_token::state::Account::LEN);\n\nlet my_pda = fuzz_accounts\n    .my_pda\n    // gets the storage of all `my_pda` account variants\n    .storage()\n    // returns the PdaStore struct of the `my_pda` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.my_pda)\n    .or_insert_with(|| {\n        let seeds = &amp;[b\"some-seeds\"];\n        let pda = Pubkey::find_program_address(seeds, &amp;my_program::id()).0;\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_for_token_acc,\n            &amp;[],\n            0,\n            &amp;SYSTEM_PROGRAM_ID,\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;pda, &amp;account);\n        let vec_of_seeds: Vec&lt;Vec&lt;u8&gt;&gt; = seeds.iter().map(|&amp;seed| seed.to_vec())\n                            .collect();\n        PdaStore {\n            pubkey: pda,\n            seeds: vec_of_seeds,\n        }\n    }).pubkey();\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p4/","title":"Define invariants checks","text":"<p>After each successful instruction execution, the <code>check()</code> method is called to check the account data invariants.</p> <p>For each instruction, you can compare the account data before and after the instruction execution such as:</p> <pre><code>fn check(\n    &amp;self,\n    pre_ix: Self::IxSnapshot,\n    post_ix: Self::IxSnapshot,\n    _ix_data: Self::IxData,\n) -&gt; Result&lt;(), &amp;'static str&gt; {\n    if let Some(escrow_pre) = pre_ix.escrow {\n        // we can unwrap the receiver account because it\n        // has to be initialized before the instruction\n        // execution and it is not supposed to be closed\n        // after the instruction execution either\n        let receiver = pre_ix.receiver.unwrap();\n        let receiver_lamports_before = receiver.lamports();\n        let receiver_lamports_after = post_ix.receiver.unwrap().lamports();\n\n        if receiver.key() != escrow_pre.receiver.key()\n            &amp;&amp; receiver_lamports_before &lt; receiver_lamports_after\n        {\n            return Err(\"Un-authorized withdrawal\");\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p5/","title":"Customize instructions generation","text":"<p>It is possible to customize how the instructions are generated and which instructions will be executed at the beginning (<code>pre_ixs</code>), in the middle (<code>ixs</code>) and at the end (<code>post_ixs</code>) of each fuzz iteration. This can be useful for example if your program needs an initialization or you want to fuzz some specific program state.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/test_fuzz.rs</code> and implement the corresponding optional method of the <code>FuzzDataBuilder&lt;FuzzInstruction&gt;</code> trait. For example, in order to always call the <code>initialize</code> instruction, modify the trait's implementation as follows:</li> </ul> <pre><code>impl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {\n    fn pre_ixs(u: &amp;mut arbitrary::Unstructured) -&gt;\n        arbitrary::Result&lt;Vec&lt;FuzzInstruction&gt;&gt; {\n        let init_ix = FuzzInstruction::Initialize(Initialize::arbitrary(u)?);\n        Ok(vec![init_ix])\n    }\n}\n</code></pre>"},{"location":"fuzzing/howto/fuzzing-howto-p6/","title":"How to use Custom Data Types","text":"<p>If you use Custom Types as Instruction data arguments, you may encounter a problem that the Custom Type does not implement</p> <ul> <li>Debug trait</li> <li>Arbitrary trait</li> </ul> <p>For example: <pre><code>#[program]\npub mod your_program {\n    pub fn init_vesting(\n            ctx: Context&lt;InitVesting&gt;,\n            recipient: Pubkey,\n            amount: u64,\n            start_at: u64,\n            end_at: u64,\n            interval: u64,\n            // Custom Type input argument\n            _input_variant: CustomEnumInput,\n    ) -&gt; Result&lt;()&gt; {\n        _init_vesting(ctx, recipient, amount, start_at, end_at, interval)\n    }\n}\n\n...\n\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub enum CustomEnumInput {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p> <p>Then inside the <code>fuzz_instructions.rs</code>, you may see:</p> <pre><code>#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n    /// IMPORTANT:\n    /// your_program::CustomEnumInput does not derive\n    /// Arbitrary, nor Debug trait\n    pub _input_variant: your_program::CustomEnumInput,\n}\n</code></pre> <p>To resolve this issue, you have two options.</p>"},{"location":"fuzzing/howto/fuzzing-howto-p6/#derive-debug-and-arbitrary-traits-inside-your-program","title":"Derive Debug and Arbitrary traits inside your program","text":"<p>This option necessitates updating the source code of your on-chain program, which might be undesirable. If you prefer not to modify your program, consider the alternative option provided below.</p> <p>Inside <code>programs/&lt;YOUR_PROGRAM&gt;/Cargo.toml</code> file include: <pre><code>...\n[dependencies]\n...\narbitrary = { version = \"1.3.0\", features = [\"derive\"] }\n...\n</code></pre></p> <p>and within the program source code: <pre><code>// derive Debug, Arbitrary\n#[derive(AnchorDeserialize, AnchorSerialize, Debug, Arbitrary)]\npub enum CustomEnumInput {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p>"},{"location":"fuzzing/howto/fuzzing-howto-p6/#derive-debug-and-arbitrary-traits-inside-the-fuzz-test","title":"Derive Debug and Arbitrary traits inside the Fuzz Test","text":"<p>You can redefine the custom type within the <code>fuzz_instructions.rs</code> file, along with all the necessary traits. <pre><code>// Redefine the Custom Type inside the fuzz_instructions.rs,\n// but this time with all of the required traits.\n#[derive(Arbitrary,Debug, Clone, Copy)]\npub enum CustomEnumInputFuzz {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p> <p>And instead of using the input argument defined within the program, you should modify it as follows: <pre><code>#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n    /// IMPORTANT:\n    /// redefined Custom Type\n    pub _input_variant: CustomEnumInputFuzz,\n}\n</code></pre></p> <p>Then, you would also need to implement the <code>std::convert::From&lt;T&gt;</code> trait to enable conversion between the newly defined Custom Type and the Custom Type used within your program. <pre><code>// implement std::convert::From to convert between CustomEnumInputFuzz\n// and your_program::CustomEnumInput as these are distinc Data Types.\nimpl std::convert::From&lt;CustomEnumInputFuzz&gt; for your_program::CustomEnumInput {\n    fn from(val: CustomEnumInputFuzz) -&gt; Self {\n        match val {\n            CustomEnumInputFuzz::InputVariant1 =&gt; {\n                your_program::CustomEnumInput::InputVariant1\n            }\n            CustomEnumInputFuzz::InputVariant2 =&gt; {\n                your_program::CustomEnumInput::InputVariant2\n            }\n            CustomEnumInputFuzz::InputVariant3 =&gt; {\n                your_program::CustomEnumInput::InputVariant3\n            }\n        }\n    }\n}\n</code></pre> Finally, within the <code>get_data</code> function, you can proceed as follows: <pre><code>impl&lt;'info&gt; IxOps&lt;'info&gt; for InitVestingData {\n    ...\n    fn get_data(\n        &amp;self,\n        _client: &amp;mut impl FuzzClient,\n        _fuzz_accounts: &amp;mut FuzzAccounts,\n    ) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n        // cast variable into correct Data Type\n        let variant = self.data._input_variant.into();\n\n        let data = your_program::instruction::InitVestingData {\n        ...\n        _input_variant:variant,\n        ...\n        };\n        Ok(data)\n    }\n    ...\n}\n</code></pre></p>"},{"location":"fuzzing/howto/fuzzing-howto-p6/#example","title":"Example","text":"<p>For a practical example, please refer to the Examples section.</p>"},{"location":"fuzzing/howto/fuzzing-howto-p7/","title":"How to use Arbitrary crate","text":"<p>The Arbitrary crate in Rust is used for generating well-typed, structured instances of data from raw byte buffers, making it useful for fuzzing by producing random but structured data for tests.</p> <p>By implementing the Arbitrary trait for Instruction Data structures, you can guide the fuzzing tool to generate meaningful instances of these structures, thus ensuring a more effective and targeted fuzzing process.</p> <p>Let`s say your Solana program contains instruction, with a similar logic as the example below: <pre><code>#[program]\npub mod your_program {\n    pub fn init_vesting(\n        ctx: Context&lt;InitVesting&gt;,\n        recipient: Pubkey,\n        amount: u64,\n        start_at: u64,\n        end_at: u64,\n        interval: u64,\n    ) -&gt; Result&lt;()&gt; {\n        _init_vesting(ctx, recipient, amount, start_at, end_at, interval)\n    }\n}\n...\npub fn _init_vesting(\n    ctx: Context&lt;InitVesting&gt;,\n    recipient: Pubkey,\n    amount: u64,\n    start_at: u64,\n    end_at: u64,\n    interval: u64,\n) -&gt; Result&lt;()&gt; {\n    ...\n    // the Instruction Data arguments are not completely random\n    // and should have the following restrictions\n    require!(amount &gt; 0, VestingError::InvalidAmount);\n    require!(end_at &gt; start_at, VestingError::InvalidTimeRange);\n    require!(end_at - start_at &gt; interval, VestingError::InvalidInterval);\n    require!(interval &gt; 0, VestingError::InvalidInterval);\n    ...\n\n}\n</code></pre></p> <p>For this purpose, you can limit the generated Instruction Data structure that is sent to the instruction by the fuzzer, in the following ways</p>"},{"location":"fuzzing/howto/fuzzing-howto-p7/#customizing-single-fields","title":"Customizing single fields","text":"<p>You can limit the generated Instruction Input Data by customizing particular fields, Check Customizing single fields for more details.</p> <p>For the example specified above, with the customization we can limit the particular fields such that <pre><code>// Instruction Data structure automatically generated\n// inside fuzz_instructions.rs\n...\n#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    // specify the range for amount\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1_000_000)\n    )]\n    pub amount: u64,\n    // specify the range for start_at , this way it will\n    // be always smaller than end_at\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(0..=1_000_000)\n    )]\n    pub start_at: u64,\n    // specify the range for end_at\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured|\n        u.int_in_range(1_001_001..=1_050_000)\n    )]\n    pub end_at: u64,\n    // specify the range for interval\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1000)\n    )]\n    pub interval: u64,\n}\n...\n</code></pre></p>"},{"location":"fuzzing/howto/fuzzing-howto-p7/#implementing-arbitrary-by-hand","title":"Implementing Arbitrary By Hand","text":"<p>Alternatively, you can write Arbitrary implementation by yourself. <pre><code>// for the given example above, this structure is automatically generated\n// with the fuzzer inside fuzz_instructions.rs\n#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n}\n</code></pre></p> <p>Now, instead of using an automatically derived Arbitrary trait, you can implement the trait by hand <pre><code>...\n#[derive(Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n}\nimpl&lt;'a&gt; Arbitrary&lt;'a&gt; for InitVestingData {\n    fn arbitrary(\n        u: &amp;mut arbitrary::Unstructured&lt;'a&gt;\n    ) -&gt; arbitrary::Result&lt;Self&gt; {\n        // obtain AccountId\n        let recipient = AccountId::arbitrary(u)?;\n\n        // limit the generated amount to the 1_000_000\n        let amount = u.int_in_range(1..=1_000_000)?;\n\n        // now we want to obtain\n        // - start_at\n        // - end_at\n        // - interval\n        // however we want to limit the data such that:\n        // - start_at &lt; end_at\n        // - end_at - start_at &gt; interval\n        // - interval has lower limit of 500 and upper limit of 1000.\n\n        let start_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let end_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let interval: u64 = u.int_in_range(500..=1000)?;\n\n        // ensure that start_at &lt; end_at\n        if start_at &gt;= end_at {\n            return Err(arbitrary::Error::IncorrectFormat);\n        }\n\n        // ensure that end_at - start_at &gt; interval\n        match end_at.checked_sub(start_at) {\n            Some(diff) =&gt; {\n                if diff &lt;= interval {\n                    return Err(arbitrary::Error::IncorrectFormat);\n                }\n            }\n            None =&gt; return Err(arbitrary::Error::IncorrectFormat),\n        }\n\n        Ok(InitVestingData {\n            recipient,\n            amount,\n            start_at,\n            end_at,\n            interval,\n        })\n    }\n}\n...\n</code></pre></p>"},{"location":"fuzzing/howto/fuzzing-howto-p7/#example","title":"Example","text":"<p>For a practical example, please refer to the Examples section.</p>"},{"location":"fuzzing/initialization/fuzzing-initialization-all/","title":"All-Suite","text":"<p>To initialize Trident and generate all-suite test templates, navigate to your project's root directory and run</p> <pre><code>trident init\n</code></pre> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 .program_client\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_0 # particular fuzz test\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 accounts_snapshots.rs # generated accounts deserialization methods\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_fuzz.rs # the binary target of your fuzz test\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fuzz_instructions.rs # the definition of your fuzz test\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_1\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_X # possible multiple fuzz tests\n\u2502   \u2502   \u251c\u2500\u2500 fuzzing # compilations and crashes folder\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u2502   \u2514\u2500\u2500 poc_tests # integration tests folder\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"fuzzing/initialization/fuzzing-initialization-fuzz-add/","title":"Add new Fuzz Test","text":"<p>If you have already initialized Trident within your project, and you are interested in initializing a new fuzz test run. <pre><code>trident fuzz add\n</code></pre></p> <p>The command will generate a new fuzz test as follows: <pre><code>project-root\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_X # new fuzz test folder\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 accounts_snapshots.rs\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_fuzz.rs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fuzz_instructions.rs\n\u2502   \u2502   \u251c\u2500\u2500 fuzzing\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml # already present\n\u251c\u2500\u2500 Trident.toml # already present\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"fuzzing/initialization/fuzzing-initialization-fuzz/","title":"Fuzz test-only","text":"<p>If you are interested only in generating templates for fuzz tests run <pre><code>trident init fuzz\n</code></pre></p> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_0 # particular fuzz test\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 accounts_snapshots.rs # generated accounts deserialization methods\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_fuzz.rs # the binary target of your fuzz test\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fuzz_instructions.rs # the definition of your fuzz test\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_1\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_X # possible multiple fuzz tests\n\u2502   \u2502   \u251c\u2500\u2500 fuzzing # compilations and crashes folder\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"home/home-installation/","title":"Installation","text":""},{"location":"home/home-installation/#dependencies","title":"Dependencies","text":"<p>Check supported versions section for further details.</p> <ul> <li>Install Rust</li> <li>Install Solana tool suite</li> <li>Install Anchor</li> <li>Install Honggfuzz-rs for fuzz testing</li> </ul>"},{"location":"home/home-installation/#installation_1","title":"Installation","text":"<pre><code>cargo install trident-cli\n\n# or the specific version\n\ncargo install --version &lt;version&gt; trident-cli\n</code></pre>"},{"location":"home/home-installation/#supported-versions","title":"Supported versions","text":"<ul> <li>We support <code>Anchor</code> and <code>Solana</code> versions specified in the table below.</li> </ul> Trident CLI Anchor Solana Rust <code>v0.6.0</code> <code>&gt;=0.29.*</code><sup>1</sup> <code>^1.17</code> <code>nightly</code> <code>v0.5.0</code> <code>~0.28.*</code> <code>=1.16.6</code> <code>v0.4.0</code> <code>~0.27.*</code> <code>&gt;=1.15</code> <code>v0.3.0</code> <code>~0.25.*</code> <code>&gt;=1.10</code> <code>v0.2.0</code> <code>~0.24.*</code> <code>&gt;=1.9</code> <ol> <li>To use Trident with Anchor 0.29.0, run the following commands from your project's root directory after Trident initialization: <pre><code>cargo update anchor-client@0.30.0 --precise 0.29.0\ncargo update anchor-spl@0.30.0 --precise 0.29.0\n</code></pre></li> </ol>"},{"location":"integration-tests/poc-examples/","title":"Examples","text":"<ul> <li>Escrow</li> <li>Turnstile</li> </ul>"},{"location":"integration-tests/poc-introduction/","title":"Introduction","text":"<p>Trident supports writing Integration Tests in Rust.</p> marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$  marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ t marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ tr marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ tri marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trid marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ tride marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ triden marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident  marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident t marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident te marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident tes marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident test marcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ trident test     Finished test [unoptimized + debuginfo] target(s) in 0.17s     Running unittests src/lib.rs (target/debug/deps/program_client-35df7129a7acbd48)running 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s     Running tests/test.rs (target/debug/deps/test-e1d41610f5897c1f)running 2 tests-------------- TEST START --------------program_keypair(1).pubkey = Po1RaS8BEDbNcn5oXsFryAeQ6Wn8fvmE111DJaKCgPCWaiting for fees to stabilize 1...test test_unhappy_path ... okWaiting for fees to stabilize 2...test test_happy_path ... oktest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 14.89s     Running unittests src/lib.rs (target/debug/deps/turnstile-451803623b25a701)running 1 testtest test_id ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s   Doc-tests program_clientmarcinv@XPS15:~/Work/tooling/trident/examples/turnstile$ exit"},{"location":"integration-tests/poc-run/","title":"Run","text":"<p>Once you have finished the implementation of the Integration Test, you can run the Test as follows:</p> <pre><code>trident test\n</code></pre>"},{"location":"integration-tests/poc-run/#skipping-tests","title":"Skipping tests","text":"<ul> <li>You can add the <code>#[ignore]</code> macro to skip the test.</li> </ul> <pre><code>#[trident_test]\n#[ignore]\nasync fn test() {}\n</code></pre>"},{"location":"integration-tests/howto/poc-howto-p0/","title":"Init Fixture","text":"<pre><code>// &lt;my_project&gt;/trident-tests/poc_tests/tests/test.rs\n// TODO: do not forget to add all necessary dependencies to the generated `trident-tests/poc_tests/Cargo.toml`\nuse program_client::my_instruction;\nuse trident_client::*;\nuse my_program;\n\n#[throws]\n#[fixture]\nasync fn init_fixture() -&gt; Fixture {\n  // create a test fixture\n  let mut fixture = Fixture {\n    client: Client::new(system_keypair(0)),\n    // make sure to pass the correct name of your program\n    program: anchor_keypair(\"my_program_name\").unwrap(),\n    state: keypair(42),\n  };\n  // deploy the program to test\n  fixture.deploy().await?;\n  // call instruction init\n  my_instruction::initialize(\n    &amp;fixture.client,\n    fixture.state.pubkey(),\n    fixture.client.payer().pubkey(),\n    System::id(),\n    Some(fixture.state.clone()),\n  ).await?;\n  fixture\n}\n\n#[trident_test]\nasync fn test_happy_path(#[future] init_fixture: Result&lt;Fixture&gt;) {\n  let fixture = init_fixture.await?;\n  // call the instruction\n  my_instruction::do_something(\n    &amp;fixture.client,\n    \"dummy_string\".to_owned(),\n    fixture.state.pubkey(),\n    None,\n  ).await?;\n  // check the test result\n  let state = fixture.get_state().await?;\n  assert_eq!(state.something_changed, \"yes\");\n}\n</code></pre>"},{"location":"integration-tests/howto/poc-howto-p1/","title":"Testing programs with associated token accounts","text":"<ul> <li><code>Trident</code> does not export <code>anchor-spl</code> and <code>spl-associated-token-account</code>, so you have to add it manually.</li> </ul> <pre><code># &lt;my-project&gt;/trident-tests/poc_tests/Cargo.toml\n# import the correct versions manually\nanchor-spl = \"0.29.0\"\nspl-associated-token-account = \"2.0.0\"\n</code></pre> <pre><code>// &lt;my-project&gt;/trident-tests/poc_tests/tests/test.rs\nuse anchor_spl::token::Token;\nuse spl_associated_token_account;\n\nasync fn init_fixture() -&gt; Fixture {\n  // ...\n  let account = keypair(1);\n  let mint = keypair(2);\n  // constructs a token mint\n  client\n    .create_token_mint(&amp;mint, mint.pubkey(), None, 0)\n    .await?;\n  // constructs associated token account\n  let token_account = client\n    .create_associated_token_account(&amp;account, mint.pubkey())\n    .await?;\n  let associated_token_program = spl_associated_token_account::id();\n  // derives the associated token account address for the given wallet and mint\n  let associated_token_address = spl_associated_token_account::get_associated_token_address(&amp;account.pubkey(), mint);\n  Fixture {\n    // ...\n    token_program: Token::id(),\n  }\n}\n</code></pre>"},{"location":"integration-tests/initialization/poc-initialization-all/","title":"All-Suite","text":"<p>To initialize Trident and generate all-suite test templates, navigate to your project's root directory and run</p> <pre><code>trident init\n</code></pre> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 .program_client\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u251c\u2500\u2500 poc_tests # integration tests folder\n\u2502   \u2502   \u251c\u2500\u2500 tests\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 test.rs # Integration Tests implementation\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"integration-tests/initialization/poc-initialization-poc/","title":"Integration test-only","text":"<p>If you are interested only in generating templates for Integration Tests run <pre><code>trident init poc\n</code></pre></p> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 .program_client\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 poc_tests # integration tests folder\n\u2502   \u2502   \u251c\u2500\u2500 tests\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 test.rs\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"integration-tests/initialization/poc-initialization-program-client/","title":"Program Client","text":"<p>By default, Integration Tests initialization generates also a <code>.program_client</code> crate with all necessary implementation for Instructions.</p> <p>If you are interested in updating the <code>.program_client</code> implementation due to an update inside your program, run <pre><code>trident build\n</code></pre></p> <p>This command will also initialize <code>.program_client</code> if the crate does not exist yet.</p>"}]}