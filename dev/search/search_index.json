{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Trident <p>Rust-based Fuzzing framework for Solana programs to help you ship secure code.</p> <ul> <li> <p> Getting Started</p> <p>Install the Trident Fuzz Testing Framework</p> <p>Installation</p> </li> <li> <p> Start Fuzzing</p> <p>Focus on security and start fuzzing immediately</p> <p>Start Fuzzing</p> </li> <li> <p> Check the GitHub for unreleased features</p> <p>Check our GitHub repository to see the unreleased features</p> <p>Trident Repository</p> </li> <li> <p> Trident by Examples</p> <p>Try the Fuzzing Examples</p> <p>Trident Examples</p> </li> </ul>"},{"location":"#what-is-fuzzing","title":"What is Fuzzing ?","text":"<p>\"Fuzz testing is an automated technique that provides generated random, invalid, or unexpected input data to your program. This helps discover unknown bugs and vulnerabilities, potentially preventing zero-day exploits.\"</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning (SemVer).</p> <p>Note: Version 0 of Semantic Versioning is handled differently from version 1 and above. The minor version will be incremented upon a breaking change and the patch version will be incremented for features.</p>"},{"location":"CHANGELOG/#dev-unreleased","title":"[dev] - Unreleased","text":"<p>Added</p> <ul> <li>impr/ added get_program_id function to the IxOps and FuzzTestExecutor (199)</li> </ul> <p>Changed</p> <ul> <li>impr/ fuzz flags are read at start of fuzzing session from Config instead of env variable and transaction dispatch was added to increase FuzzTestExecutor readability (204)</li> <li>impr/ allow various instructions to be generated in case of multiple programs in the Anchor workspace (200)</li> <li>feat/ option to add account into Fuzz Test environment with base64 data (197)</li> <li>impr/ instead of parsing source code and creating our IDL, read anchor IDL (198)</li> </ul> <p>Removed</p> <ul> <li>del/remove integration tests supported by Trident, this feature adds more unnecessary overhead compared to its value (196)</li> </ul>"},{"location":"CHANGELOG/#070-2024-08-14","title":"[0.7.0] - 2024-08-14","text":"<p>Added</p> <ul> <li>impr/ add feature flag to the AccountsSnapshots macro (183)</li> <li>feat/ add Support for CPI (182)</li> <li>feat/ add option to initialize Trident with Macro/File (for Snapshots) option based on preference (179)</li> <li>feat/create AccountsSnapshots derive macro for Snapshots creation (#177)</li> <li>feat/fuzzing moved to separate crate trident-fuzz (#175)</li> <li>feat/unify dependencies provided by the Trident (#172)</li> <li>feat/fuzzer-stats-logging, an optional statistics output for fuzzing session (#144)</li> </ul> <p>Fixed</p> <ul> <li>fix/in case of fuzzing failure throw error instead of only printing message (#167)</li> <li>fix/snapshot's zeroed account as optional (#170)</li> </ul> <p>Removed</p> <ul> <li>del/remove localnet subcommand (178)</li> <li>del/remove unnecessary fuzzing feature as trident is mainly fuzzer (#176)</li> <li>del/remove Trident explorer (#171)</li> </ul>"},{"location":"CHANGELOG/#060-2024-05-20","title":"[0.6.0] - 2024-05-20","text":"<p>Added</p> <ul> <li>feat/anchor 0.30.0 support (#148)</li> <li>fix/allow to process duplicate transactions (#147)</li> <li>feat/possibility to implement custom transaction error handling (#145)</li> <li>feat/support of automatically obtaining fully qualified paths of Data Accounts Custom types for <code>accounts_snapshots.rs</code> (#141)</li> <li>feat/allow direct accounts manipulation and storage (#142)</li> <li>feat/support of non-corresponding instruction and context names (#130)</li> <li>feat/refactored and improved program flow during init and build, added activity indicator (#129)</li> <li>feat/allow solana versions up to v1.17.* and pin Rust 1.77 nightly compiler (#128)</li> <li>feat/new init command option to initialize fuzz or poc tests only (#124)</li> <li>feat/debug-mode detailed output (#125)</li> <li>feat/anchor 0.29.0 support (#121)</li> <li>doc/add help comment + update documentation (#120)</li> <li>feat/fuzzer error handling (#118)</li> <li>feat/convert fuzz Pubkey to AccountId (#116)</li> <li>feat/additional anchor types (#115)</li> <li>feat/import ToAccountInfo trait in fuzzing prelude (#113)</li> <li>test/added code generation and macros tests (#112)</li> <li>feat/fuzzer framework core, macros, helpers, templates, and examples. (#111)</li> <li>feat/improved trident-tests folder structure for PoC and Fuzz Tests (#109)</li> <li>feat/support for additional fuzzer parameters in Trident.toml config file (#107)</li> <li>feat/posibility to pass params to the fuzzer via Trident.toml config file (#106)</li> <li>feat/client now reads by default keypair from default location (#105)</li> <li>feat/added new --exit-code option to return corresponding exit code based on fuzz test result (#104)</li> <li>feat/removed/updated deprecated functions, removed allow deprecated macros (#103)</li> <li>feat/added new function to read keypair file generated by Anchor (#102)</li> <li>feat/clean command (#101)</li> <li>feat/improved program_client generated code (#100)</li> <li>feat/automatically add hfuzz_target to .gitignore file (#99)</li> <li>feat/support for dynamic templates. (#98)</li> </ul> <p>Fixed</p> <ul> <li>fix/refactored fuzz test executor error handling (#127)</li> <li>fix/warn user on composite accounts and continue fuzz test generation (#133)</li> <li>fix/progress bar loop lock release (#132)</li> <li>fix/fixed fuzz test generation with init-if-needed Anchor feature (#131)</li> <li>fix/program client custom types (#117)</li> <li>fix/check fuzz test name collision by checking the name against HashSet (#114)</li> </ul>"},{"location":"CHANGELOG/#050-2023-08-28","title":"[0.5.0] - 2023-08-28","text":"<p>Added</p> <ul> <li>cli: Added trident subcommand <code>fuzz</code> to run and debug fuzz tests using honggfuzz-rs.</li> <li>cli: Added trident <code>--skip-fuzzer</code> option for <code>init</code> subcommand to skip generation of fuzz test templates.</li> <li>client: Added new Cargo feature <code>fuzzing</code> that enables optional dependencies related to fuzz testing.</li> </ul>"},{"location":"CHANGELOG/#041-2023-08-21","title":"[0.4.1] - 2023-08-21","text":"<p>Changed</p> <ul> <li>Upgrade Solana (<code>=1.16.6</code>) and Anchor framework (<code>=0.28.0</code>) versions.</li> </ul> <p>Fixed</p> <ul> <li>Implemented Anchor Client logic was not able to work with newer version of Anchor. Fixed with <code>async_rpc</code> and <code>async</code> feature.</li> <li>Trident init IDL Parse Error on newer version of Rust, fixed with updated <code>accounts</code> token.</li> </ul>"},{"location":"CHANGELOG/#030-2022-09-23","title":"[0.3.0] - 2022-09-23","text":"<p>Changed</p> <ul> <li>Upgrade Solana (<code>~1.10</code>) and Anchor framework (<code>~0.25</code>) versions</li> </ul> <p>Added</p> <ul> <li>Custom Solana RPC error reporter. If the Solana RPC error is thrown, the error code, message and data (logs) are reported to the output.</li> <li>Custom imports in the <code>.program_client</code>. User is able to import custom types and structures into program client. The import part of the code would not be re-generated.</li> </ul>"},{"location":"CHANGELOG/#020-2022-07-27","title":"[0.2.0] - 2022-07-27","text":"<p>Added</p> <ul> <li>Trident is now configurable. This requires <code>Trident.toml</code> file to exist in the project's root directory - without this file the execution will fail. To solve this re-run <code>trident init</code> or just create an empty <code>Trident.toml</code> file in the project's root directory.</li> </ul>"},{"location":"commands/commands/","title":"Commands","text":""},{"location":"commands/commands/#trident-init","title":"trident init","text":"<ul> <li> <p>This command Initializes Trident Workspace and generates new Fuzz Test Template.</p> </li> <li> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_0 # particular fuzz test\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_fuzz.rs # the binary target of your fuzz test\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fuzz_instructions.rs # the definition of your fuzz test\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_1\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_X # possible multiple fuzz tests\n\u2502   \u2502   \u251c\u2500\u2500 fuzzing # compilations and crashes folder\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p> </li> </ul>"},{"location":"commands/commands/#trident-fuzz","title":"trident fuzz","text":"<ul> <li>This command behavior depends on the subcommands.</li> </ul>"},{"location":"commands/commands/#trident-fuzz-run","title":"trident fuzz run","text":"<ul> <li>Run Fuzzer on the specified Fuzz Target (i.e. the Fuzz Template, for example fuzz_0).</li> </ul>"},{"location":"commands/commands/#trident-fuzz-run-debug","title":"trident fuzz run-debug","text":"<ul> <li>Run debug on the specified Fuzz Target (i.e. the Fuzz Template, for example fuzz_0), with specified crash file, to see where the crash file found an issue.</li> </ul>"},{"location":"commands/commands/#trident-fuzz-add","title":"trident fuzz add","text":"<ul> <li>Adds new Fuzz Test Template.</li> </ul>"},{"location":"commands/commands/#trident-clean","title":"trident clean","text":"<ul> <li>Calls <code>anchor clean</code> and cleans targets created by the underlying Honggfuzz. Crashfiles and Fuzzing Inputs are preserved.</li> </ul>"},{"location":"examples/examples/","title":"Trident by Examples","text":"<ul> <li> <p> Hello World!</p> <p>Hello World example with Trident.</p> <p>Hello World!</p> </li> <li> <p> Possible vulnerabilities and bugs</p> <p>Check the possible attack vectors and bugs that can be detected using Trident.</p> <p>Unchecked Arithmetic</p> <p>Incorrect Instruction Sequence</p> <p>Unauthorized Access</p> <p>Incorrect Integer Arithmetic</p> </li> <li> <p> Customize with Arbitrary</p> <p>You can use Arbitrary crate to your advantage and limit or customize the data that are sent to the instructions.</p> <p>Custom Data Types</p> <p>Limiting Instructions Inputs</p> </li> <li> <p> Cross-Program Invocation</p> <p>Trident supports Cross-Program Invocation, you can fuzz your programs and create NFTs at the same time.</p> <p>Simple CPI</p> <p>CPI with Metaplex Metadata Program</p> </li> </ul>"},{"location":"faq/faq/","title":"FAQ","text":""},{"location":"faq/faq/#is-trident-supported-only-with-anchor","title":"Is Trident supported only with Anchor ?","text":"<ul> <li>Currently yes, Trident under the hood obtains data from the IDL generated by Anchor and it has to have access to the AccountsSnapshots derived for each Instruction Context.</li> </ul>"},{"location":"faq/faq/#i-created-the-fuzz-test-what-should-i-do-next","title":"I created the Fuzz Test what should I do next ?","text":"<ul> <li>Start here Writing Fuzz Tests. For additional features check Features. If you are not sure about anything check Get Help</li> </ul>"},{"location":"faq/faq/#my-program-instruction-contains-custom-type-such-as-struct-or-enum-on-its-input-but-it-does-not-derive-arbitrary","title":"My program Instruction contains custom type such as Struct or Enum on its input, but it does not derive Arbitrary.","text":"<ul> <li>In this case you need to specify same type in the Fuzz Test (with the same fields). And implement From Trait to convert to your type. Check Custom Data Types or Examples of Arbitrary.</li> </ul>"},{"location":"faq/faq/#is-trident-open-source","title":"Is Trident open-source ?","text":"<ul> <li>Yes, here Trident</li> </ul>"},{"location":"faq/faq/#i-would-like-to-report-issue-with-trident-what-should-i-do","title":"I would like to report Issue with Trident, what should I do ?","text":"<ul> <li>Write Issue Issues</li> </ul>"},{"location":"faq/faq/#is-trident-deployed-on-mainnet-devnet-testenet","title":"Is Trident deployed on Mainnet / Devnet / Testenet ?","text":"<ul> <li>No, Trident is Fuzz Testing Framework, not Solana Program.</li> </ul>"},{"location":"faq/faq/#what-type-of-fuzzer-trident-is","title":"What type of Fuzzer Trident is ?","text":"<ul> <li>Currently, we refer to it as \"coverage guided gray box fuzzer\".</li> </ul>"},{"location":"features/account-storages/","title":"Account Storages","text":"<p>Trident allows developers to generate random accounts for fuzzing.</p> <p>However, the Accounts are not completely random, and neither are the Account addresses.</p> <p>Instead, Trident generates random AccountIDs which are indexes to Account Storages. Each unique Account contained within the Anchor generated IDL has its own AccountStorage. The FuzzAccounts containing the Accounts Storages is global to all Instructions to use.</p> Note <p>Details:</p> <p>Always generating only random accounts would in most cases lead to a situation where the fuzzer would be stuck because the accounts would be almost every time rejected by your Anchor program. Therefore it is necessary to specify, what accounts should be used and also limit the number of newly created accounts to reduce the space complexity.</p> <p>Important</p> <p>Currently, supported types of Account Storages:</p> <ul> <li>Signer</li> <li>PDA</li> <li>Token Account</li> <li>Program account</li> </ul> <p>Then use the corresponding AccountsStorage.</p> <pre><code>pub struct FuzzAccounts {\n    signer: AccountsStorage&lt;Keypair&gt;,\n    some_pda: AccountsStorage&lt;PdaStore&gt;,\n    token_vault: AccountsStorage&lt;TokenStore&gt;,\n    mint: AccountsStorage&lt;MintStore&gt;,\n    // ...\n}\n</code></pre> <p>Tip</p> <p>Keep in mind:</p> <ul> <li>You do not need to specify every <code>AccountStorage</code>, some accounts do not necessarily need to be stored in their corresponding storage.<ul> <li>For example <code>System Program</code> does not need to be stored, rather can be used from the <code>solana_sdk</code>.</li> </ul> </li> <li>If you are about to Initialize <code>Mint</code> or <code>Token Account</code> in your Solana Program.<ul> <li>use <code>Keypair</code> or <code>PdaStore</code> (not <code>MintStore</code> or <code>TokenStore</code>).</li> </ul> </li> <li>If you are going to initialize <code>Associated Token Account</code> in your Solana Program.<ul> <li>use <code>PdaStore</code>.</li> </ul> </li> <li>You can rename fields of <code>FuzzAccounts</code> to whatever you want. The default names are generated based on the Program's <code>IDL</code>.</li> </ul> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/arbitrary-data/","title":"Arbitrary Data","text":"<p>Trident allows you to customize Instruction Data to provide structure.</p> <p>For example your Initialize Instruction expects two arguments <code>start_at</code> and <code>end_at</code> you know that in order for the Instruction to make sense, it is required that the <code>start_at</code> &lt; <code>end_at</code>. Moreover, there should be significant difference between these two. This can be utilized with the Arbitrary crate.</p> <pre><code>#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1_000_000)\n    )]\n    pub amount: u64,\n    // we want start_at smaller than end_at\n    // and for testing purposes we can run tests with times from the past\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(0..=1_000_000)\n    )]\n    pub start_at: u64,\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1_001_001..=1_050_000)\n    )]\n    pub end_at: u64,\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1000)\n    )]\n    pub interval: u64,\n}\n</code></pre>"},{"location":"features/arbitrary-data/#implement-arbitrary","title":"Implement Arbitrary","text":"<p>There are macros available to use with Arbitrary, however, it is possible to Implement the arbitrary function by yourself.</p> <pre><code>// -------------------------------------------------------------------\n// -------------------------------------------------------------------\n// Implement Arbitrary\nimpl&lt;'a&gt; Arbitrary&lt;'a&gt; for InitVestingData {\n    fn arbitrary(\n        u: &amp;mut arbitrary::Unstructured&lt;'a&gt;\n    ) -&gt; arbitrary::Result&lt;Self&gt; {\n        // obtain AccountId\n        let recipient = AccountId::arbitrary(u)?;\n\n        // limit the generated amount to the 1_000_000\n        let amount = u.int_in_range(1..=1_000_000)?;\n\n        // now we want to obtain\n        // - start_at\n        // - end_at\n        // - interval\n        // however we want to limit the data such that:\n        // - start_at &lt; end_at\n        // - end_at - start_at &gt; interval\n        // - interval has lower limit of 500 and upper limit of 1000.\n\n        let start_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let end_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let interval: u64 = u.int_in_range(500..=1000)?;\n\n        // ensure that start_at &lt; end_at\n        if start_at &gt;= end_at {\n            return Err(arbitrary::Error::IncorrectFormat);\n        }\n\n        // ensure that end_at - start_at &gt; interval\n        match end_at.checked_sub(start_at) {\n            Some(diff) =&gt; {\n                if diff &lt;= interval {\n                    return Err(arbitrary::Error::IncorrectFormat);\n                }\n            }\n            None =&gt; return Err(arbitrary::Error::IncorrectFormat),\n        }\n\n        Ok(InitVestingData {\n            recipient,\n            amount,\n            start_at,\n            end_at,\n            interval,\n        })\n    }\n    // -------------------------------------------------------------------\n    // -------------------------------------------------------------------\n}\n</code></pre>"},{"location":"features/arbitrary-data/#custom-data-types","title":"Custom Data Types","text":"<p>If you use Custom Types as Instruction data arguments, you may encounter a problem that the Custom Type does not implement</p> <ul> <li>Debug trait</li> <li>Arbitrary trait</li> </ul>"},{"location":"features/arbitrary-data/#derive-debug-and-arbitrary-traits-inside-the-fuzz-test","title":"Derive Debug and Arbitrary traits inside the Fuzz Test","text":"<p>You can redefine the custom type within the <code>fuzz_instructions.rs</code> file, along with all the necessary traits.</p> <pre><code>// Redefine the Custom Type inside the fuzz_instructions.rs,\n// but this time with all of the required traits.\n#[derive(Arbitrary,Debug, Clone, Copy)]\npub enum CustomEnumInputFuzz {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre> <p>Then, you would also need to implement the <code>std::convert::From&lt;T&gt;</code> trait to enable conversion between the newly defined Custom Type and the Custom Type used within your program.</p> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/error-handlers/","title":"Error Handler","text":"<p>Trident allows you to specify custom error handler for each Instruction.</p> <p>This can be particularly helpful:</p> <ul> <li>If Transaction returns Error, you can specify to omit this error and continue with the fuzzing instruction.</li> <li>Using the <code>tx_error_handler</code> you can check if the error returned is desired based on the Accounts and Input data that were used.</li> </ul> <p>Tip</p> <p>The default behavior of the function is that the error is returned.</p> <pre><code>/// default implementation\nfn tx_error_handler(\n    &amp;self,\n    e: FuzzClientErrorWithOrigin,\n    ix_data: Self::IxData,\n    pre_ix_acc_infos: &amp;'info mut [Option&lt;AccountInfo&lt;'info&gt;&gt;],\n) -&gt; Result&lt;(), FuzzClientErrorWithOrigin&gt; {\n    Err(e)\n}\n</code></pre> <p>To omit the Error and continue with the next Instruction in the iteration, you can do</p> <pre><code>/// default implementation\nfn tx_error_handler(\n    &amp;self,\n    e: FuzzClientErrorWithOrigin,\n    ix_data: Self::IxData,\n    pre_ix_acc_infos: &amp;'info mut [Option&lt;AccountInfo&lt;'info&gt;&gt;],\n) -&gt; Result&lt;(), FuzzClientErrorWithOrigin&gt; {\n    Ok(())\n}\n</code></pre>"},{"location":"features/features/","title":"Trident Features","text":"<p>Trident contains multiple features to enhance the fuzzing experience and increase ability to discover bugs.</p> <ul> <li> <p> AccountStorages</p> <p>Initialize, store and re-use random Accounts.</p> <p>AccountStorages</p> </li> <li> <p> FuzzInstructions</p> <p>All available Program Instructions as FuzzInstructions Variants.</p> <p>FuzzInstructions</p> </li> <li> <p> Custom Instruction Sequences</p> <p>Specify Instruction Sequqnces you would like to executed instead of completely random execution order.</p> <p>Custom Instruction Sequences</p> </li> <li> <p> Invariant Checks</p> <p>Allows to compare Account contents before and after the Instruction was successfully executed.</p> <p>Invariant Checks</p> </li> <li> <p> Genesis Accounts</p> <p>Specify genesis Accounts that will be included in the Fuzzing Environment. Use Mainnet Programs or dumped Accounts.</p> <p>Genesis</p> </li> <li> <p> Fuzzing Statistics</p> <p>Show Fuzzing Statistics after the Fuzzing Session ended.</p> <p>Fuzzing Statistics</p> </li> <li> <p> Arbitrary Data</p> <p>Customize structure of Instruction Input arguments.</p> <p>Arbitrary Data</p> </li> <li> <p> Trident Manifest</p> <p>Customize Fuzzing experience with the Trident Manifest.</p> <p>Trident Manifest</p> </li> <li> <p> Custom Error Handlers</p> <p>Continue Instruction Sequence in case of Instruction Error was returned or specify custom behavior based on the returned error.</p> <p>Custom Error Handlers</p> </li> </ul>"},{"location":"features/fuzz-instructions/","title":"Fuzz Instructions","text":"<p>Trident defines <code>FuzzInstruction</code> enum containing all available Instructions within your program.</p> <p>The enum variants additionally contains their corresponding structures for Accounts and Input arguments.</p> <pre><code>#[derive(Arbitrary, DisplayIx, FuzzTestExecutor, FuzzDeserialize)]\npub enum FuzzInstruction {\n    Initialize(Initialize),\n    Update(Update),\n}\n#[derive(Arbitrary, Debug)]\npub struct Initialize {\n    pub accounts: InitializeAccounts,\n    pub data: InitializeData,\n}\n#[derive(Arbitrary, Debug)]\npub struct Update {\n    pub accounts: UpdateAccounts,\n    pub data: UpdateData,\n}\n// ...\n</code></pre>"},{"location":"features/fuzz-instructions/#instruction-behavior","title":"Instruction behavior","text":"<p>Each Instruction variant has to define <code>IxOps</code> trait containing the following methods:</p> <ul> <li><code>get_program_id()</code> (required)</li> <li><code>get_data()</code> (required)</li> <li><code>get_accounts()</code> (required)</li> <li><code>check()</code> (optional)</li> <li><code>tx_error_handler()</code> (optional)</li> <li><code>deserialize_accounts()</code> (automatically implemented)</li> </ul>"},{"location":"features/fuzz-instructions/#get-program-id","title":"Get Program ID","text":"<p>This method specifies program ID to which the Instruction corresponds.</p> <p>In case you have only one program in the Anchor Workspace it is not really important. The importance occurs when you have multiple programs in the Workspace and you want to call Instructions of every Program. In that case each Instruction Variant corresponds to its program by the Program ID.</p>"},{"location":"features/fuzz-instructions/#get-data","title":"Get Data","text":"<p>This method specifies what the Instruction Input Data should look like. You can use completely random data generated by the fuzzer, such as:</p> <pre><code>fn get_data(\n    &amp;self,\n    _client: &amp;mut impl FuzzClient,\n    _fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n    let data = hello_world::instruction::InitializeFn {\n        input: self.data.input,\n    };\n    Ok(data)\n}\n</code></pre> <p>You can also use always constant values</p> <pre><code>fn get_data(\n    &amp;self,\n    _client: &amp;mut impl FuzzClient,\n    _fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n    let data = hello_world::instruction::InitializeFn {\n        input: 5,\n    };\n    Ok(data)\n}\n</code></pre> <p>Or you can customize the Data using the Arbitrary crate. Check Arbitrary Data.</p>"},{"location":"features/fuzz-instructions/#get-accounts","title":"Get Accounts","text":"<p>This method specifies how the Accounts for the corresponding Instruction should be resolved. You can use accounts stored within the FuzzAccounts Account Storages, or you can define custom Account using the client.</p> <p>Important</p> <p>Source Code below</p> <ul> <li>Take the author from the <code>FuzzAccounts</code> Account Storage author on <code>self.accounts.author</code> index. If Account on that index does not exist yet, it will be created and returned. In case it is already created, the corresponding Account will be returned.</li> <li><code>hello_world_account</code> Account Storage is of type PdaStore, in this case <code>get_or_create_account</code> function do the same as for the authority, but you need to specify seeds to derive its PDA.</li> <li>Next, you need to specify signers if there should be any.</li> <li>Lastly, specify the Account Metas of the corresponding Instruction.<ul> <li>for example <code>&lt;program_name&gt;::accounts::&lt;context_name&gt; {}.to_account_metas(None);</code></li> </ul> </li> </ul> <pre><code>fn get_accounts(\n    &amp;self,\n    client: &amp;mut impl FuzzClient,\n    fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;(Vec&lt;Keypair&gt;, Vec&lt;AccountMeta&gt;), FuzzingError&gt; {\n    let author = fuzz_accounts.author.get_or_create_account(\n        self.accounts.author,\n        client,\n        5 * LAMPORTS_PER_SOL,\n    );\n\n    let hello_world_account = fuzz_accounts\n        .hello_world_account\n        .get_or_create_account(\n            self.accounts.hello_world_account,\n            &amp;[b\"hello_world_seed\"],\n            &amp;hello_world::ID,\n        )\n        .unwrap();\n    let signers = vec![author.clone()];\n    let acc_meta = hello_world::accounts::InitializeContext {\n        author: author.pubkey(),\n        hello_world_account: hello_world_account.pubkey(),\n        system_program: solana_sdk::system_program::ID,\n    }\n    .to_account_metas(None);\n    Ok((signers, acc_meta))\n}\n</code></pre>"},{"location":"features/fuzz-instructions/#create-an-arbitrary-account","title":"Create an arbitrary account","text":"<p>The <code>AccountsStorage&lt;T&gt;</code> type provides an implementation of the <code>get_or_create_account</code> method that helps you create new or read already existing accounts. There are different implementations for different types of storage (<code>Keypair</code>, <code>TokenStore</code>, <code>MintStore</code>, <code>PdaStore</code>) to simplify the creation of new accounts.</p> <p>However, there are cases when the provided implementation is not sufficient and it is necessary to create an account manually. These cases can be (but are not limited to) for example:</p> <ul> <li>you need to create a new account with a predefined address</li> <li>you need to create a new account that is not owned by the system program</li> <li>you need to create and initialize a new PDA account</li> <li>your program expects an account to be initialized in a previous instruction</li> </ul> <p>In that case, you can use the <code>storage</code> method of the <code>AccountsStorage&lt;T&gt;</code> struct that exposes the underlying <code>HashMap&lt;AccountId, T&gt;</code> and you can add new accounts directly to it.</p> <p>It is possible to create and store any kind of account. For example:</p> <ul> <li>to add an account that uses the <code>#[account(zero)]</code> anchor constraint (must be rent exempt, owned by your program, with empty data):</li> </ul> <pre><code>let state = fuzz_accounts\n    .state\n    // gets the storage of all `state` account variants\n    .storage()\n    // returns the Keypair of the `state` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.state)\n    .or_insert_with(|| {\n        let space = State::SIZE;\n        let rent_exempt_lamports = client.get_rent().unwrap()\n                            .minimum_balance(space);\n        let keypair = Keypair::new();\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_lamports,\n            &amp;[],\n            space,\n            &amp;my_program::id(),\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;keypair.pubkey(), &amp;account);\n        keypair\n    });\n</code></pre> <ul> <li>to add a new system-owned account with a specific PDA (address):</li> </ul> <pre><code>let rent_exempt_for_token_acc = client\n    .get_rent()\n    .unwrap()\n    .minimum_balance(anchor_spl::token::spl_token::state::Account::LEN);\n\nlet my_pda = fuzz_accounts\n    .my_pda\n    // gets the storage of all `my_pda` account variants\n    .storage()\n    // returns the PdaStore struct of the `my_pda` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.my_pda)\n    .or_insert_with(|| {\n        let seeds = &amp;[b\"some-seeds\"];\n        let pda = Pubkey::find_program_address(seeds, &amp;my_program::id()).0;\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_for_token_acc,\n            &amp;[],\n            0,\n            &amp;SYSTEM_PROGRAM_ID,\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;pda, &amp;account);\n        let vec_of_seeds: Vec&lt;Vec&lt;u8&gt;&gt; = seeds.iter().map(|&amp;seed| seed.to_vec())\n                            .collect();\n        PdaStore {\n            pubkey: pda,\n            seeds: vec_of_seeds,\n        }\n    }).pubkey();\n</code></pre>"},{"location":"features/fuzz-instructions/#check","title":"Check","text":"<p>This method provides Invariant Check for the corresponding Instruction. Check Invariant Checks.</p>"},{"location":"features/fuzz-instructions/#tx-error-handler","title":"Tx Error Handler","text":"<p>This method provides Tx Error Handler for the corresponding Instruction. Check Error Handler.</p>"},{"location":"features/fuzz-instructions/#example","title":"Example","text":"<p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/fuzzing-statistics/","title":"Fuzzing Statistics","text":"<p>Trident allows you to see statistics after the fuzzing session ended.</p> <p>Important</p> <p>In order to show statistics set <code>fuzzing_with_stats</code> within the <code>Trident.toml</code> to <code>true</code>.</p> <pre><code>[fuzz]\n# ...\nfuzzing_with_stats = true\n# ...\n</code></pre>"},{"location":"features/fuzzing-statistics/#available-statistics","title":"Available Statistics","text":""},{"location":"features/fuzzing-statistics/#simple","title":"Simple","text":"<ul> <li>Number of invocations of each instruction during the fuzzing session.</li> <li>Number of successful invocations of each instruction during the fuzzing session.</li> <li>Number of failed invariants checks for each instruction during the fuzzing session.</li> </ul> Note <p>Keep in mind that the number of fuzz iterations does not directly correspond to the total number of invocations. In one fuzz iteration, the fuzzer might be unable to deserialize fuzz data into instructions, causing the entire iteration to be skipped.</p> <p>On the other hand this is expected behavior as the underlying data are randomly (with coverage feedback) generated, so the Honggfuzz will not necessarily find appropriate data each iteration.</p> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/genesis-accounts/","title":"Genesis","text":""},{"location":"features/genesis-accounts/#genesis-programs","title":"Genesis Programs","text":"<p>Trident allows you to use Cross Program Invocation of both Native and SBF programs.</p>"},{"location":"features/genesis-accounts/#native","title":"Native","text":"<p>In case of multiple programs within the Anchor Workspace. Make sure that all of the programs you would like to call Cross Program Invocation to are included in the initial state of the Fuzz Test Environment.</p> <p>Important</p> <p>Source code below:</p> <ul> <li><code>fuzzing_program_callee</code> is included in the <code>ProgramTestClientBlocking</code></li> <li><code>fuzzing_program_caller</code> is included in the <code>ProgramTestClientBlocking</code></li> </ul> <pre><code>// test_fuzz.rs\n\nfn fuzz_iteration&lt;T: FuzzTestExecutor&lt;U&gt; + std::fmt::Display, U&gt;(\n    fuzz_data: FuzzData&lt;T, U&gt;\n) {\n    let fuzzing_program_callee = FuzzingProgram::new(\n        PROGRAM_NAME_CALLEE,\n        &amp;PROGRAM_ID_CALLEE,\n        processor!(convert_entry!(entry_callee)),\n    );\n\n    let fuzzing_program_caller = FuzzingProgram::new(\n        PROGRAM_NAME_CALLER,\n        &amp;PROGRAM_ID_CALLER,\n        processor!(convert_entry!(entry_caller)),\n    );\n\n    let mut client =\n        ProgramTestClientBlocking::new(\n            &amp;[fuzzing_program_callee, fuzzing_program_caller],\n            &amp;[]\n        ).unwrap();\n\n    let _ = fuzz_data.run_with_runtime(&amp;mut client);\n}\n</code></pre>"},{"location":"features/genesis-accounts/#sbf","title":"SBF","text":"<p>In case of SBF targets, compiled or dumped from whatever cluster. You can also use these within the Fuzz Tests.</p> <p>Important</p> <p>To include the SBF target in the Fuzz Test for CPI</p> <ul> <li>Specify program entry to <code>None</code>.</li> <li>Store the SBF target in the <code>trident-genesis</code> folder in the root of the workspace.</li> <li>Name of the program has to be the same as name of the dumbed SBF target in the trident-genesis (without .so).</li> </ul> <pre><code>fn fuzz_iteration&lt;T: FuzzTestExecutor&lt;U&gt; + std::fmt::Display, U&gt;(\n    fuzz_data: FuzzData&lt;T, U&gt;\n) {\n\n    let fuzzing_program_cpi_metaplex_7 = FuzzingProgram::new(\n        PROGRAM_NAME_CPI_METAPLEX_7,\n        &amp;PROGRAM_ID_CPI_METAPLEX_7,\n        processor!(convert_entry!(entry_cpi_metaplex_7)),\n    );\n\n    let metaplex = FuzzingProgram::new(\n        \"metaplex-token-metadata\",\n        &amp;mpl_token_metadata::ID,\n        None\n    );\n\n    let mut client =\n        ProgramTestClientBlocking::new(\n            &amp;[fuzzing_program_cpi_metaplex_7, metaplex],\n            &amp;[]\n        ).unwrap();\n\n    let _ = fuzz_data.run_with_runtime(&amp;mut client);\n}\n</code></pre>"},{"location":"features/genesis-accounts/#genesis-accounts","title":"Genesis Accounts","text":"<p>Trident allows you to include Accounts with data in base64 format.</p> <p>Tip</p> <p>If you want to obtain Account with <code>base64</code> data format, use</p> <pre><code># -u m specifies to dump from mainnet\nsolana account -u m &lt;ADDRESS&gt; --output json\n</code></pre> <pre><code>fn fuzz_iteration&lt;T: FuzzTestExecutor&lt;U&gt; + std::fmt::Display, U&gt;(\n    fuzz_data: FuzzData&lt;T, U&gt;\n) {\n\n    let fuzzing_program_cpi_metaplex_7 = FuzzingProgram::new(\n        PROGRAM_NAME_CPI_METAPLEX_7,\n        &amp;PROGRAM_ID_CPI_METAPLEX_7,\n        processor!(convert_entry!(entry_cpi_metaplex_7)),\n    );\n\n    let custom_account = FuzzingAccountBase64::new(\n        ACCOUNT_ADDRESS,\n        LAMPORTS,\n        OWNER,\n        \"AQAAALL8+z4UH4TCY/N8hU0XmNZYMU9r04EadnC4rxQcc\", // base64 data format\n    );\n\n    let mut client =\n        ProgramTestClientBlocking::new(\n            &amp;[fuzzing_program_cpi_metaplex_7],\n            &amp;[custom_account] // Include here\n        ).unwrap();\n\n    let _ = fuzz_data.run_with_runtime(&amp;mut client);\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/instructions-sequences/","title":"Instructions Sequences","text":"<p>Trident allows you to specify Custom Instruction Sequences you would like to execute.</p> <p>Possible Instruction sequences are split into 3 parts</p> <ul> <li>pre-Instructions</li> <li>Instructions</li> <li>post-Instructions</li> </ul> <p>For example if you program always needs to start with some kind of Initialization instruction, you can specify this Initialize Instruction in <code>pre_ixs</code> as shown in the source code below.</p> <p>Tip</p> <ul> <li>returning <code>Ok(vec![])</code> will result in None Instructions executed in the corresponding part.</li> </ul> <pre><code>// test_fuzz.rs\n\n// do not forget to include the required structures\nuse fuzz_instructions::InitVesting;\nuse fuzz_instructions::WithdrawUnlocked;\n\nimpl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {\n    fn pre_ixs(\n        u: &amp;mut arbitrary::Unstructured\n    ) -&gt; arbitrary::Result&lt;Vec&lt;FuzzInstruction&gt;&gt; {\n        let init_ix =\n            FuzzInstruction::InitVesting(InitVesting::arbitrary(u)?);\n\n        Ok(vec![init_ix])\n    }\n    fn ixs(\n        u: &amp;mut arbitrary::Unstructured\n    ) -&gt; arbitrary::Result&lt;Vec&lt;FuzzInstruction&gt;&gt; {\n        let withdraw_ix =\n            FuzzInstruction::WithdrawUnlocked(WithdrawUnlocked::arbitrary(u)?);\n\n        Ok(vec![withdraw_ix])\n    }\n    fn post_ixs(\n        _u: &amp;mut arbitrary::Unstructured\n    ) -&gt; arbitrary::Result&lt;Vec&lt;FuzzInstruction&gt;&gt; {\n        Ok(vec![])\n    }\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/invariant-checks/","title":"Invariant Checks","text":"<p>Trident allows you to (optionally) specify Invariant Checks for each Instruction.</p> <p>The Invariant Check will be called after the Instruction was successfully invoked. Within the Invariant Check you can compare the contents of Accounts before and after the Instruction was called.</p> <p>Important</p> <p>Returning error in the Invariant Check is considered as detected undesired behavior (i.e. issue/crash detected).</p> <pre><code>fn check(\n    &amp;self,\n    _pre_ix: Self::IxSnapshot,\n    post_ix: Self::IxSnapshot,\n    _ix_data: Self::IxData,\n) -&gt; Result&lt;(), FuzzingError&gt; {\n    if let Some(hello_world_account) = post_ix.hello_world_account {\n        if hello_world_account.input == 253 {\n            return Err(FuzzingError::Custom(1));\n        }\n    }\n    Ok(())\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"features/lifecycle/","title":"Fuzz Test Lifecycle","text":"<p>In the sequence diagram below you can see a simplified fuzz test lifecycle.</p> <p>Some diagram states are labeled with emojis:</p> <ul> <li>\u26a1 Mandatory methods that must be implemented by the user.</li> <li>\ud83d\udc64 Optional methods that can be implemented by the user.</li> </ul>"},{"location":"features/lifecycle/#lifecycle","title":"Lifecycle","text":"<ol> <li>The fuzzer is running until:<ol> <li>The maximal number of iterations is reached (if specified).</li> <li>A crash was detected and the <code>exit_upon_crash</code> parameter was set.</li> <li>User interrupted the test manually (for example by hitting <code>CTRL+C</code>).</li> </ol> </li> <li>In each iteration, the fuzzer generates a sequence of random instructions to execute.<ol> <li>User can optionally customize how the instructions are generated and can specify the instructions that should be executed at the beginning (<code>pre_ixs</code>), in the middle (<code>ixs</code>) and at the end (<code>post_ixs</code>) of each iteration. This can be useful for example if your program needs an initialization or you want to fuzz some specific program state.</li> </ol> </li> <li>For each instruction:<ol> <li>User defined mandatory method <code>get_accounts()</code> is called to collect necessary instruction accounts.</li> <li>User defined mandatory method <code>get_data()</code> is called to collect instruction data.</li> <li>A snapshot of all instruction accounts before the instruction execution is saved.</li> <li>The instruction is executed.</li> <li>A snapshot of all instruction accounts after the instruction execution is saved.</li> <li>User defined optional method <code>check()</code> is called to check accounts data and evaluate invariants.</li> </ol> </li> </ol> fuzzer_iterations = 0fuzzer_iterations = 0fuzzer_iterations &lt;\u00a0max_iterationsfuzzer_iterations &lt;...donedonecreate pre-instruction\u00a0accounts snapshotscreate pre-instruction...execute instructionexecute instructioncreate post-instruction\u00a0accounts snapshotscreate post-instruction...check invariants \ud83d\udc64check invariants \ud83d\udc64fuzzer_iterations++fuzzer_iterations++Generate instructionspre_ixs \ud83d\udc64pre_ixs \ud83d\udc64ixs \ud83d\udc64ixs \ud83d\udc64post_ixs \ud83d\udc64post_ixs \ud83d\udc64endendfor ix in instructionsfor ix in instructionsget instruction accounts \u26a1get instruction accounts \u26a1get instruction data \u26a1get instruction data \u26a1next ixnext ixText is not SVG - cannot display"},{"location":"features/limitations/","title":"Current limitations","text":"<p>This section summarizes some known limitations in the current development stage. Further development will be focused on resolving these limitations.</p> <ul> <li>Remaining accounts in check methods are not supported.</li> <li>Composite accounts are not supported.</li> </ul>"},{"location":"features/trident-manifest/","title":"Trident Manifest","text":"<p>You can pass supported parameters via the Trident.toml configuration file:</p> <pre><code># Content of Trident.toml\n[honggfuzz]\n# Timeout in seconds (default: 10)\ntimeout = 10\n# Number of fuzzing iterations (default: 0 [no limit])\niterations = 0\n# Number of concurrent fuzzing threads (default: 0 [number of CPUs / 2])\nthreads = 0\n# Don't close children's stdin, stdout, stderr; can be noisy (default: false)\nkeep_output = false\n# Disable ANSI console; use simple log output (default: false)\nverbose = false\n# Exit upon seeing the first crash (default: false)\nexit_upon_crash = false\n# Maximal number of mutations per one run (default: 6)\nmutations_per_run = 6\n# Target compilation directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_target\"]).\n# To not clash with cargo build's default target directory.\ncargo_target_dir = \"\"\n# Honggfuzz working directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_workspace\"]).\nhfuzz_workspace = \"\"\n# Directory where crashes are saved to (default: \"\" [workspace directory])\ncrashdir = \"\"\n# Input file extension (e.g. 'swf'), (default: \"\" ['fuzz'])\nextension = \"\"\n# Number of seconds this fuzzing session will last (default: 0 [no limit])\nrun_time = 0\n# Maximal size of files processed by the fuzzer in bytes (default: 1048576 = 1MB)\nmax_file_size = 1048576\n# Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames (default: false)\nsave_all = false\n\n[fuzz]\n# Allow processing of duplicate transactions. Setting to true might speed up fuzzing but can cause false positive crashes (default: false)\nallow_duplicate_txs = false\n# Trident will show statistics after the fuzzing session. This option forces use of honggfuzz parameter\n# `keep_output` as true in order to be able to catch fuzzer stdout. (default: false)\nfuzzing_with_stats = true\n</code></pre>"},{"location":"features/trident-manifest/#honggfuzz","title":"[honggfuzz]","text":""},{"location":"features/trident-manifest/#timeout","title":"timeout","text":"<ul> <li>Timeout in seconds (default: 10)</li> </ul>"},{"location":"features/trident-manifest/#iterations","title":"iterations","text":"<ul> <li>Number of fuzzing iterations (default: 0 [no limit])</li> </ul>"},{"location":"features/trident-manifest/#threads","title":"threads","text":"<ul> <li>Number of concurrent fuzzing threads (default: 0 [number of CPUs / 2])</li> </ul>"},{"location":"features/trident-manifest/#keep_output","title":"keep_output","text":"<ul> <li>Don't close children's stdin, stdout, stderr; can be noisy (default: false)</li> </ul>"},{"location":"features/trident-manifest/#verbose","title":"verbose","text":"<ul> <li>Disable ANSI console; use simple log output (default: false)</li> </ul>"},{"location":"features/trident-manifest/#exit_upon_crash","title":"exit_upon_crash","text":"<ul> <li>Exit upon seeing the first crash (default: false)</li> </ul>"},{"location":"features/trident-manifest/#mutations_per_run","title":"mutations_per_run","text":"<ul> <li>Maximal number of mutations per one run (default: 6)</li> </ul>"},{"location":"features/trident-manifest/#cargo_target_dir","title":"cargo_target_dir","text":"<ul> <li>Target compilation directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_target\"]).</li> <li>To not clash with cargo build's default target directory.</li> </ul>"},{"location":"features/trident-manifest/#hfuzz_workspace","title":"hfuzz_workspace","text":"<ul> <li>Honggfuzz working directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_workspace\"]).</li> </ul>"},{"location":"features/trident-manifest/#crashdir","title":"crashdir","text":"<ul> <li>Directory where crashes are saved to (default: \"\" [workspace directory])</li> </ul>"},{"location":"features/trident-manifest/#extension","title":"extension","text":"<ul> <li>Input file extension (e.g. 'swf'), (default: \"\" ['fuzz'])</li> </ul>"},{"location":"features/trident-manifest/#run_time","title":"run_time","text":"<ul> <li>Number of seconds this fuzzing session will last (default: 0 [no limit])</li> </ul>"},{"location":"features/trident-manifest/#max_file_size","title":"max_file_size","text":"<ul> <li>Maximal size of files processed by the fuzzer in bytes (default: 1048576 = 1MB)</li> </ul>"},{"location":"features/trident-manifest/#save_all","title":"save_all","text":"<ul> <li>Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames (default: false)</li> </ul>"},{"location":"features/trident-manifest/#fuzz","title":"[fuzz]","text":""},{"location":"features/trident-manifest/#allow_duplicate_txs","title":"allow_duplicate_txs","text":"<ul> <li>Allow processing of duplicate transactions. Setting to true might speed up fuzzing but can cause false positive crashes (default: false)</li> </ul>"},{"location":"features/trident-manifest/#fuzzing_with_stats","title":"fuzzing_with_stats","text":"<ul> <li>Trident will show statistics after the fuzzing session. This option forces use of honggfuzz parameter <code>keep_output</code> as true in order to be able to catch fuzzer stdout. (default: false)</li> </ul> Note <p>Or you can pass any parameter via environment variables.</p> <p>A list of hongfuzz parameters can be found in honggfuzz usage documentation. The parameters passed via environment variables have higher priority. For example:</p> <pre><code># Time-out: 10 secs\n# Number of concurrent fuzzing threads: 1\n# Number of fuzzing iterations: 10000\n# Display Solana logs in the terminal\nHFUZZ_RUN_ARGS=\"-t 10 -n 1 -N 10000 -Q\" trident fuzz run &lt;TARGET_NAME&gt;\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"get-help/get-help/","title":"Get Help","text":"<p>Need help writing Fuzz Tests? Do not hesitate to join our Discord server!</p>"},{"location":"installation/installation/","title":"Installation","text":"<p>Tip</p> <p>Docker Image down below.</p> <p>Important</p> <p>Prerequisite</p> <p>It is expected that you have installed:</p> <ul> <li>Rust (Install Rust)</li> <li>Solana CLI (Install Solana CLI)</li> <li>Anchor Framework (Install Anchor)</li> </ul> <p>For supported versions check the Supported Versions</p>"},{"location":"installation/installation/#install-system-dependencies","title":"Install System Dependencies","text":"<p>Update your package list and install the required packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y \\\n    curl \\\n    git \\\n    build-essential \\\n    pkg-config \\\n    libssl-dev \\\n    npm \\\n    vim \\\n    nano \\\n    wget \\\n    binutils-dev \\\n    libunwind-dev \\\n    lldb\n</code></pre>"},{"location":"installation/installation/#install-trident-and-honggfuzz","title":"Install Trident and Honggfuzz","text":"<p>Install them using the following commands:</p> <pre><code>cargo install trident-cli\ncargo install honggfuzz\n</code></pre>"},{"location":"installation/installation/#supported-versions","title":"Supported versions","text":"Trident CLI Anchor Solana Rust Honggfuzz <code>develop</code> <code>0.30.1</code> <code>^1.17.4</code> <code>nightly</code> <code>0.5.56</code> <code>v0.7.0</code> <code>&gt;=0.29.*</code><sup>1</sup> <code>^1.17.4</code> <code>nightly</code> <code>0.5.56</code> <code>v0.6.0</code> <code>&gt;=0.29.*</code><sup>1</sup> <code>^1.17</code> <code>nightly</code> <code>0.5.55</code> <code>v0.5.0</code> <code>~0.28.*</code> <code>=1.16.6</code> - - <code>v0.4.0</code> <code>~0.27.*</code> <code>&gt;=1.15</code> - - <code>v0.3.0</code> <code>~0.25.*</code> <code>&gt;=1.10</code> - - <code>v0.2.0</code> <code>~0.24.*</code> <code>&gt;=1.9</code> - - <ol> <li>To use Trident with Anchor 0.29.0, run the following commands from your project's root directory after Trident initialization: <pre><code>cargo update anchor-client@0.30.0 --precise 0.29.0\ncargo update anchor-spl@0.30.0 --precise 0.29.0\n</code></pre></li> </ol>"},{"location":"installation/installation/#docker-image","title":"Docker Image","text":"<p>TBD</p>"},{"location":"writing-fuzz-test/writing-fuzz-test/","title":"Writing fuzz test","text":""},{"location":"writing-fuzz-test/writing-fuzz-test/#initialization","title":"Initialization","text":""},{"location":"writing-fuzz-test/writing-fuzz-test/#initialize-fuzz-test","title":"Initialize Fuzz Test","text":"<p>Initialize Trident in the Anchor-based workspace.</p> <pre><code>trident init\n</code></pre> <p>Info</p> <p>Trident under the hood</p> <ul> <li>Builds the Anchor-based project.</li> <li>Reads the generated IDL.</li> <li>Based on the IDL creates the fuzzing template.</li> </ul>"},{"location":"writing-fuzz-test/writing-fuzz-test/#add-new-fuzz-test","title":"Add new Fuzz Test","text":"<p>Info</p> <p>This step is optional, <code>trident init</code> will generate the first fuzz test template. Use <code>trident fuzz add</code> in case you want to add additional Template.</p> <p>Add new Fuzz Test if Trident is already initialized.</p> <pre><code>trident fuzz add\n</code></pre>"},{"location":"writing-fuzz-test/writing-fuzz-test/#fill-the-fuzz-test-template","title":"Fill the Fuzz test Template","text":""},{"location":"writing-fuzz-test/writing-fuzz-test/#derive-accountssnapshots","title":"Derive AccountsSnapshots","text":"<p>In the <code>Cargo.toml</code> file of each of the Anchor-based program within the workspace, define the required dependencies and feature as shown in the example below.</p> <p>Important</p> <p>Please pay attention only to the:</p> <ul> <li><code>trident-fuzzing = [\"dep:trident-fuzz\"]</code>.</li> <li><code>trident-derive-accounts-snapshots = \"version goes here\"</code>.</li> <li><code>trident-fuzz = { version = \"version goes here\", optional = true }</code>.</li> <li>If you are unsure what versions to use check the Supported Versions.</li> </ul> <p>Tip</p> <p>The feature <code>trident-fuzzing = [\"dep:trident-fuzz\"]</code> ensures that the <code>AccountsSnapshots</code> are used only with the Trident.</p> <pre><code>[package]\nname = \"...\"\nversion = \"0.1.0\"\ndescription = \"Created with Anchor\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\nname = \"...\"\n\n[features]\ndefault = []\ncpi = [\"no-entrypoint\"]\nno-entrypoint = []\nno-idl = []\nno-log-ix-name = []\nidl-build = [\"anchor-lang/idl-build\"]\ntrident-fuzzing = [\"dep:trident-fuzz\"] # !!!!\n\n[dependencies]\ntrident-derive-accounts-snapshots = \"version goes here\" # !!!!\ntrident-fuzz = { version = \"version goes here\", optional = true } # !!!!\n\n\n# ...\n</code></pre> <p>For every Account Context specified in the Anchor project derive <code>AccountsSnapshots</code> such as:</p> <pre><code>// ...\n\nuse trident_derive_accounts_snapshots::AccountsSnapshots;\n\n// ...\n\n\n#[derive(Accounts, AccountsSnapshots)]\npub struct InitializeContext&lt;'info&gt; {\n    #[account(mut)]\n    pub author: Signer&lt;'info&gt;,\n    #[account(\n        init,\n        payer=author,\n        space=8+100,\n        seeds=[b\"hello_world_seed\"],\n        bump\n    )]\n    pub hello_world_account: Account&lt;'info, StoreHelloWorld&gt;,\n    pub system_program: Program&lt;'info, System&gt;,\n    // ...\n\n}\n</code></pre>"},{"location":"writing-fuzz-test/writing-fuzz-test/#link-the-accountssnapshots","title":"Link the AccountsSnapshots","text":"<p>Fuzz Instructions use the derived <code>AccountsSnapshots</code>. In this case we need to link the derived <code>AccountsSnapshots</code> to the corresponding aliases.</p> <p>Important</p> <p>Modules where the Contexts (with the derived AccountsSnapshots) are specified need to be public.</p> <pre><code>// fuzz_instructions.rs\n\nuse hello_world::trident_fuzz_initialize_context_snapshot::InitializeContextAlias;\n\ntype InitializeFnSnapshot&lt;'info&gt; = InitializeContextAlias&lt;'info&gt;;\n</code></pre> <p>Tip</p> <p>For more examples, check the Examples.</p>"},{"location":"writing-fuzz-test/writing-fuzz-test/#define-fuzz-accounts","title":"Define Fuzz Accounts","text":"<p>Define <code>AccountsStorage</code> type for each Account you would like to use.</p> <p>Important</p> <p>Keep in mind:</p> <ul> <li>You do not need to specify every <code>AccountStorage</code>, some accounts do not necessarily need to be stored in their corresponding storage.<ul> <li>For example <code>System Program</code> does not need to be stored, rather can be used from the <code>solana_sdk</code>.</li> </ul> </li> <li>If you are about to Initialize <code>Mint</code> or <code>Token Account</code> in your Solana Program.<ul> <li>use <code>Keypair</code> or <code>PdaStore</code> (not <code>MintStore</code> or <code>TokenStore</code>).</li> </ul> </li> <li>If you are going to initialize <code>Associated Token Account</code> in your Solana Program.<ul> <li>use <code>PdaStore</code>.</li> </ul> </li> <li>You can rename <code>FuzzAccounts</code> fields to whatever you want. The default names were generated based on the Program's <code>IDL</code>.</li> </ul> <pre><code>#[doc = r\" Use AccountsStorage&lt;T&gt; where T can be one of:\"]\n#[doc = r\" Keypair, PdaStore, TokenStore, MintStore, ProgramStore\"]\n#[derive(Default)]\npub struct FuzzAccounts {\n    author: AccountsStorage&lt;Keypair&gt;,\n    hello_world_account: AccountsStorage&lt;PdaStore&gt;,\n    // No need to fuzz system_program\n    // system_program: AccountsStorage&lt;todo!()&gt;,\n}\n</code></pre> <p>Tip</p> <p>For more details about the <code>AccountsStorage</code> check AccountsStorage.</p>"},{"location":"writing-fuzz-test/writing-fuzz-test/#implement-fuzz-instructions","title":"Implement Fuzz Instructions","text":"<p>Each Instruction in the Fuzz Test has to have defined the following functions:</p> <ul> <li><code>get_program_id()</code><ul> <li>Specifies to which program the Instruction belongs. This function is automatically defined and should not need any updates. The importance is such that if you have multiple programs in your workspace, Trident can generate Instruction Sequences of Instruction corresponding to different programs.</li> </ul> </li> <li><code>get_data()</code><ul> <li>Specifies what Instruction inputs are send to the Program Instructions.</li> </ul> </li> <li><code>get_accounts()</code><ul> <li>Specifies what Accounts are send to the Program Instructions.</li> </ul> </li> </ul> <p>Tip</p> <ul> <li>For more info about how to write these functions, check the Fuzz Instructions.</li> <li>For the examples how to write these functions, check the Examples.</li> </ul>"},{"location":"writing-fuzz-test/writing-fuzz-test/#execute","title":"Execute","text":""},{"location":"writing-fuzz-test/writing-fuzz-test/#run-fuzz-test","title":"Run Fuzz Test","text":"<p>To execute the desired fuzz test, run:</p> <pre><code># Replace &lt;TARGET_NAME&gt; with the name of particular\n# fuzz test (for example: \"fuzz_0\")\ntrident fuzz run &lt;TARGET_NAME&gt;\n</code></pre> <p>Important</p> <p>The output provided by Honggfuzz is as follows:</p> <ol> <li>Number of Fuzzing Iterations.</li> <li>Feedback Driven Mode = Honggfuzz generates data based on the feedback (i.e. feedback based on Coverage progress).</li> <li>Average Iterations per second.</li> <li>Number of crashes it found (panics or failed invariant checks).</li> </ol> <pre><code>------------------------[  0 days 00 hrs 00 mins 01 secs ]----------------------\n  Iterations : 688 (out of: 1000 [68%]) # -- 1. --\n  Mode [3/3] : Feedback Driven Mode # -- 2. --\n      Target : trident-tests/fuzz_tests/fuzzing.....wn-linux-gnu/release/fuzz_0\n     Threads : 16, CPUs: 32, CPU%: 1262% [39%/CPU]\n       Speed : 680/sec [avg: 688] # -- 3. --\n     Crashes : 1 [unique: 1, blocklist: 0, verified: 0] # -- 4. --\n    Timeouts : 0 [10 sec]\n Corpus Size : 98, max: 1048576 bytes, init: 0 files\n  Cov Update : 0 days 00 hrs 00 mins 00 secs ago\n    Coverage : edge: 10345/882951 [1%] pc: 163 cmp: 622547\n---------------------------------- [ LOGS ] ------------------/ honggfuzz 2.6 /-\n</code></pre>"},{"location":"writing-fuzz-test/writing-fuzz-test/#debug-fuzz-test","title":"Debug Fuzz Test","text":"<p>To debug your program with values from a crash file:</p> <pre><code># fuzzer will run the &lt;TARGET_NAME&gt; with the specified &lt;CRASH_FILE_PATH&gt;\ntrident fuzz run-debug &lt;TARGET_NAME&gt; &lt;CRASH_FILE_PATH&gt;\n</code></pre> <p>Tip</p> <p>By default, the crashfiles are stored in the <code>trident-tests/fuzz_tests/fuzzing/hfuzz_workspace/&lt;FUZZ_TARGET&gt;</code>.</p> <p>Important</p> <p>The debug output is at current development stage really verbose and contains lldb parts. We are working on improving this experience. In the picture below you can see an example of provided debug output.</p> <ol> <li>Series of Transaction Logs</li> <li>Structures of data send within the Instructions</li> <li>Panic or Crash, based on if the Fuzzing panicked within the Solana Program or Invariant Check failed.</li> </ol> <p></p>"}]}