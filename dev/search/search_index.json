{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trident","text":"<p>Rust-based Fuzzing framework for Solana programs to help you ship secure code.</p> <ul> <li> <p> Getting Started</p> <p>Install the Trident Fuzz Testing Framework</p> <p>Getting started</p> </li> <li> <p> Start Fuzzing</p> <p>Focus on security and start fuzzing immediatelly</p> <p>Start Fuzzing</p> </li> <li> <p> Check the GitHub for unreleased features</p> <p>Check our GitHub repository to see the unreleased features</p> <p>Trident Repository</p> </li> <li> <p> Trident by Examples</p> <p>Try the Fuzzing Examples</p> <p>Trident Examples</p> </li> </ul>"},{"location":"#what-is-fuzzing","title":"What is Fuzzing ?","text":"<p>\"Fuzz testing is an automated technique that provides generated random, invalid, or unexpected input data to your program. This helps discover unknown bugs and vulnerabilities, potentially preventing zero-day exploits.\"</p> <p>Trident equips developers with tools to efficiently develop fuzz tests for Anchor-based programs. It streamlines the fuzz testing process through automation and comprehensive support</p> <ul> <li> <p>Trident Workflow</p> <ul> <li>Automatically parses Anchor-based programs to generate necessary implementations for deserializing instruction accounts.</li> <li>Generates templates for developers to customize according to the specific needs of their fuzz test scenarios.</li> <li>Offers derive macros to effortlessly implement required traits, reducing manual coding efforts.</li> <li>Includes a bank client and helper functions for simplified account management during testing.</li> <li>Provides a Command-Line Interface (CLI) for executing and debugging fuzz tests with ease.</li> </ul> </li> <li> <p>Trident Capabilities</p> <ul> <li>Execution Order of Instructions: Test different sequences and their effects on the program to uncover sequence-related vulnerabilities.</li> <li>Instruction Parameters: Identify how variations in inputs influence program behavior, testing for robustness against a wide range of data.</li> <li>Instruction Accounts: Explore the impact of different account states on the software's functionality, ensuring comprehensive account testing.</li> <li>Comprehensive Testing: Conduct thorough and effective fuzz testing by combining any of the above aspects.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning (SemVer).</p> <p>Note: Version 0 of Semantic Versioning is handled differently from version 1 and above. The minor version will be incremented upon a breaking change and the patch version will be incremented for features.</p>"},{"location":"CHANGELOG/#dev-unreleased","title":"[dev] - Unreleased","text":"<p>Added</p> <ul> <li>impr/ added get_program_id function to the IxOps and FuzzTestExecutor (199)</li> </ul> <p>Changed</p> <ul> <li>feat/ option to add account into Fuzz Test environment with base64 data (197)</li> <li>impr/ instead of parsing source code and creating our IDL, read anchor IDL (198)</li> </ul> <p>Removed - del/remove integration tests supported by Trident, this feature adds more unnecessary overhead compared to its value (196)</p>"},{"location":"CHANGELOG/#070-2024-08-14","title":"[0.7.0] - 2024-08-14","text":"<p>Added</p> <ul> <li>impr/ add feature flag to the AccountsSnapshots macro (183)</li> <li>feat/ add Support for CPI (182)</li> <li>feat/ add option to initialize Trident with Macro/File (for Snapshots) option based on preference (179)</li> <li>feat/create AccountsSnapshots derive macro for Snapshots creation (#177)</li> <li>feat/fuzzing moved to separate crate trident-fuzz (#175)</li> <li>feat/unify dependencies provided by the Trident (#172)</li> <li>feat/fuzzer-stats-logging, an optional statistics output for fuzzing session (#144)</li> </ul> <p>Fixed</p> <ul> <li>fix/in case of fuzzing failure throw error instead of only printing message (#167)</li> <li>fix/snapshot's zeroed account as optional (#170)</li> </ul> <p>Removed</p> <ul> <li>del/remove localnet subcommand (178)</li> <li>del/remove unnecessary fuzzing feature as trident is mainly fuzzer (#176)</li> <li>del/remove Trident explorer (#171)</li> </ul>"},{"location":"CHANGELOG/#060-2024-05-20","title":"[0.6.0] - 2024-05-20","text":"<p>Added</p> <ul> <li>feat/anchor 0.30.0 support (#148)</li> <li>fix/allow to process duplicate transactions (#147)</li> <li>feat/possibility to implement custom transaction error handling (#145)</li> <li>feat/support of automatically obtaining fully qualified paths of Data Accounts Custom types for <code>accounts_snapshots.rs</code> (#141)</li> <li>feat/allow direct accounts manipulation and storage (#142)</li> <li>feat/support of non-corresponding instruction and context names (#130)</li> <li>feat/refactored and improved program flow during init and build, added activity indicator (#129)</li> <li>feat/allow solana versions up to v1.17.* and pin Rust 1.77 nightly compiler (#128)</li> <li>feat/new init command option to initialize fuzz or poc tests only (#124)</li> <li>feat/debug-mode detailed output (#125)</li> <li>feat/anchor 0.29.0 support (#121)</li> <li>doc/add help comment + update documentation (#120)</li> <li>feat/fuzzer error handling (#118)</li> <li>feat/convert fuzz Pubkey to AccountId (#116)</li> <li>feat/additional anchor types (#115)</li> <li>feat/import ToAccountInfo trait in fuzzing prelude (#113)</li> <li>test/added code generation and macros tests (#112)</li> <li>feat/fuzzer framework core, macros, helpers, templates, and examples. (#111)</li> <li>feat/improved trident-tests folder structure for PoC and Fuzz Tests (#109)</li> <li>feat/support for additional fuzzer parameters in Trident.toml config file (#107)</li> <li>feat/posibility to pass params to the fuzzer via Trident.toml config file (#106)</li> <li>feat/client now reads by default keypair from default location (#105)</li> <li>feat/added new --exit-code option to return corresponding exit code based on fuzz test result (#104)</li> <li>feat/removed/updated deprecated functions, removed allow deprecated macros (#103)</li> <li>feat/added new function to read keypair file generated by Anchor (#102)</li> <li>feat/clean command (#101)</li> <li>feat/improved program_client generated code (#100)</li> <li>feat/automatically add hfuzz_target to .gitignore file (#99)</li> <li>feat/support for dynamic templates. (#98)</li> </ul> <p>Fixed</p> <ul> <li>fix/refactored fuzz test executor error handling (#127)</li> <li>fix/warn user on composite accounts and continue fuzz test generation (#133)</li> <li>fix/progress bar loop lock release (#132)</li> <li>fix/fixed fuzz test generation with init-if-needed Anchor feature (#131)</li> <li>fix/program client custom types (#117)</li> <li>fix/check fuzz test name collision by checking the name against HashSet (#114)</li> </ul>"},{"location":"CHANGELOG/#050-2023-08-28","title":"[0.5.0] - 2023-08-28","text":"<p>Added</p> <ul> <li>cli: Added trident subcommand <code>fuzz</code> to run and debug fuzz tests using honggfuzz-rs.</li> <li>cli: Added trident <code>--skip-fuzzer</code> option for <code>init</code> subcommand to skip generation of fuzz test templates.</li> <li>client: Added new Cargo feature <code>fuzzing</code> that enables optional dependencies related to fuzz testing.</li> </ul>"},{"location":"CHANGELOG/#041-2023-08-21","title":"[0.4.1] - 2023-08-21","text":"<p>Changed</p> <ul> <li>Upgrade Solana (<code>=1.16.6</code>) and Anchor framework (<code>=0.28.0</code>) versions.</li> </ul> <p>Fixed</p> <ul> <li>Implemented Anchor Client logic was not able to work with newer version of Anchor. Fixed with <code>async_rpc</code> and <code>async</code> feature.</li> <li>Trident init IDL Parse Error on newer version of Rust, fixed with updated <code>accounts</code> token.</li> </ul>"},{"location":"CHANGELOG/#030-2022-09-23","title":"[0.3.0] - 2022-09-23","text":"<p>Changed</p> <ul> <li>Upgrade Solana (<code>~1.10</code>) and Anchor framework (<code>~0.25</code>) versions</li> </ul> <p>Added</p> <ul> <li>Custom Solana RPC error reporter. If the Solana RPC error is thrown, the error code, message and data (logs) are reported to the output.</li> <li>Custom imports in the <code>.program_client</code>. User is able to import custom types and structures into program client. The import part of the code would not be re-generated.</li> </ul>"},{"location":"CHANGELOG/#020-2022-07-27","title":"[0.2.0] - 2022-07-27","text":"<p>Added</p> <ul> <li>Trident is now configurable. This requires <code>Trident.toml</code> file to exist in the project's root directory - without this file the execution will fail. To solve this re-run <code>trident init</code> or just create an empty <code>Trident.toml</code> file in the project's root directory.</li> </ul>"},{"location":"fuzzing/execute/debug/","title":"Debug","text":"<p>To debug your program with values from a crash file:</p> <pre><code># fuzzer will run the &lt;TARGET_NAME&gt; with the specified &lt;CRASH_FILE_PATH&gt;\ntrident fuzz run-debug &lt;TARGET_NAME&gt; &lt;CRASH_FILE_PATH&gt;\n</code></pre> <p>Tip</p> <p>By default, the crashfiles are stored in the <code>trident-tests/fuzz_tests/fuzzing/hfuzz_workspace/&lt;FUZZ_TARGET&gt;</code>.</p>"},{"location":"fuzzing/execute/debug/#debug-output","title":"Debug Output","text":"<p>Important</p> <p>The debug output is at current development stage really verbose and contains lldb parts. We are working on improving this experience. In the picture below you can see an example of provided debug output.</p> <ol> <li>Series of Transaction Logs</li> <li>Structures of data send within the Instructions</li> <li>Panic or Crash, based on if the Fuzzing paniced within the Solana Program or Invariant Check failed.</li> </ol> <p></p>"},{"location":"fuzzing/execute/run/","title":"Run","text":"<p>To execute the desired fuzz test, run:</p> <pre><code># Replace &lt;TARGET_NAME&gt; with the name of particular\n# fuzz test (for example: \"fuzz_0\")\ntrident fuzz run &lt;TARGET_NAME&gt;\n</code></pre>"},{"location":"fuzzing/execute/run/#trident-output","title":"Trident output","text":"<p>Important</p> <p>The output provided by Honggfuzz is as follows</p> <ol> <li>Number of Fuzzing Iterations.</li> <li>Feedback Driven Mode = Honggfuzz generates data based on the feedback (i.e. feedback based on Coverage progress).</li> <li>Average Iterations per second</li> <li>Number of crashes it found (panics or failed invariant checks)</li> </ol> <pre><code>------------------------[  0 days 00 hrs 00 mins 01 secs ]----------------------\n  Iterations : 688 (out of: 1000 [68%]) # -- 1. --\n  Mode [3/3] : Feedback Driven Mode # -- 2. --\n      Target : trident-tests/fuzz_tests/fuzzing.....wn-linux-gnu/release/fuzz_0\n     Threads : 16, CPUs: 32, CPU%: 1262% [39%/CPU]\n       Speed : 680/sec [avg: 688] # -- 3. --\n     Crashes : 1 [unique: 1, blocklist: 0, verified: 0] # -- 4. --\n    Timeouts : 0 [10 sec]\n Corpus Size : 98, max: 1048576 bytes, init: 0 files\n  Cov Update : 0 days 00 hrs 00 mins 00 secs ago\n    Coverage : edge: 10345/882951 [1%] pc: 163 cmp: 622547\n---------------------------------- [ LOGS ] ------------------/ honggfuzz 2.6 /-\n</code></pre>"},{"location":"fuzzing/execute/run/#customize-fuzzing","title":"Customize Fuzzing","text":"<p>Under the hood Trident uses honggfuzz-rs.</p> <p>You can pass supported parameters via the Trident.toml configuration file:</p> <pre><code># Content of Trident.toml\n[honggfuzz]\n# Timeout in seconds (default: 10)\ntimeout = 10\n# Number of fuzzing iterations (default: 0 [no limit])\niterations = 0\n# Number of concurrent fuzzing threads (default: 0 [number of CPUs / 2])\nthreads = 0\n# Don't close children's stdin, stdout, stderr; can be noisy (default: false)\nkeep_output = false\n# Disable ANSI console; use simple log output (default: false)\nverbose = false\n# Exit upon seeing the first crash (default: false)\nexit_upon_crash = false\n# Maximal number of mutations per one run (default: 6)\nmutations_per_run = 6\n# Target compilation directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_target\"]).\n# To not clash with cargo build's default target directory.\ncargo_target_dir = \"\"\n# Honggfuzz working directory, (default: \"\" [\"trident-tests/fuzz_tests/fuzzing/hfuzz_workspace\"]).\nhfuzz_workspace = \"\"\n# Directory where crashes are saved to (default: \"\" [workspace directory])\ncrashdir = \"\"\n# Input file extension (e.g. 'swf'), (default: \"\" ['fuzz'])\nextension = \"\"\n# Number of seconds this fuzzing session will last (default: 0 [no limit])\nrun_time = 0\n# Maximal size of files processed by the fuzzer in bytes (default: 1048576 = 1MB)\nmax_file_size = 1048576\n# Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames (default: false)\nsave_all = false\n\n[fuzz]\n# Allow processing of duplicate transactions. Setting to true might speed up fuzzing but can cause false positive crashes (default: false)\nallow_duplicate_txs = false\n# Trident will show statistics after the fuzzing session. This option forces use of honggfuzz parameter\n# `keep_output` as true in order to be able to catch fuzzer stdout. (default: false)\nfuzzing_with_stats = true\n</code></pre> Note <p>Or you can pass any parameter via environment variables.</p> <p>A list of hongfuzz parameters can be found in honggfuzz usage documentation. The parameters passed via environment variables have higher priority. For example:</p> <pre><code># Time-out: 10 secs\n# Number of concurrent fuzzing threads: 1\n# Number of fuzzing iterations: 10000\n# Display Solana logs in the terminal\nHFUZZ_RUN_ARGS=\"-t 10 -n 1 -N 10000 -Q\" trident fuzz run &lt;TARGET_NAME&gt;\n</code></pre>"},{"location":"fuzzing/execute/statistics/","title":"Fuzzing statistics","text":"<p>Important</p> <p>In order to show statistics of fuzzing session (statistics are displayed after the fuzzing session ended), set <code>fuzzing_with_stats</code> within the Trident.toml to <code>true</code>.</p> <pre><code>[fuzz]\n# ...\nfuzzing_with_stats = true\n# ...\n</code></pre> <p>Currently exported statistics from the Fuzzing Session</p>"},{"location":"fuzzing/execute/statistics/#simple","title":"Simple","text":"<ul> <li>Number of invocations of each instruction during the fuzzing session.</li> <li>Number of successful invocations of each instruction during the fuzzing session.</li> <li>Number of failed invariants checks for each instruction during the fuzzing session.</li> </ul> Note <p>Keep in mind that the number of fuzz iterations does not directly correspond to the total number of invocations. In one fuzz iteration, the fuzzer might be unable to deserialize fuzz data into instructions, causing the entire iteration to be skipped.</p> <p>On the other hand this is expected behavior as the underlying data are randomly (with coverage feedback) generated, so the Honggfuzz will not necessarily find appropriate data each iteration.</p>"},{"location":"fuzzing/extra/current-limitations/","title":"Current limitations","text":"<p>This section summarizes some known limitations in the current development stage. Further development will be focused on resolving these limitations.</p> <ul> <li>Remaining accounts in check methods are not supported.</li> <li>Composite accounts are not supported (however it is possible to generate a fuzz test and finish the composite accounts deserialization manually).</li> </ul>"},{"location":"fuzzing/extra/examples/","title":"Trident by Examples","text":"<ul> <li> <p> Hello World!</p> <p>Hello World example with Trident.</p> <p>Hello World!</p> </li> <li> <p> Possible vulnerabilities and bugs</p> <p>Check the possible attack vectors and bugs that can be detected using Trident.</p> <p>Unchecked Arithmetic</p> <p>Incorrect Instruction Sequence</p> <p>Unauthorized Access</p> <p>Incorrect Integer Arithmetic</p> </li> <li> <p> Customize with Arbitrary</p> <p>You can use Arbitrary crate to your advantage and limit or customize the data that are sent to the instructions.</p> <p>Custom Data Types</p> <p>Limiting Instructions Inputs</p> </li> <li> <p> Cross-Program Invocation</p> <p>Trident supports Cross-Program Invocation, you can fuzz your programs and create NFTs at the same time.</p> <p>Simple CPI</p> <p>CPI with Metaplex Metadata Program</p> </li> </ul>"},{"location":"fuzzing/extra/lifecycle/","title":"Fuzz Test Lifecycle","text":"<p>In the sequence diagram below you can see a simplified fuzz test lifecycle.</p> <p>Some diagram states are labeled with emojis:</p> <ul> <li>\u26a1 Mandatory methods that must be implemented by the user.</li> <li>\ud83d\udc64 Optional methods that can be implemented by the user.</li> </ul>"},{"location":"fuzzing/extra/lifecycle/#lifecycle","title":"Lifecycle","text":"<ol> <li>The fuzzer is running until:<ol> <li>The maximal number of iterations is reached (if specified).</li> <li>A crash was detected and the <code>exit_upon_crash</code> parameter was set.</li> <li>User interrupted the test manually (for example by hitting <code>CTRL+C</code>).</li> </ol> </li> <li>In each iteration, the fuzzer generates a sequence of random instructions to execute.<ol> <li>User can optionally customize how the instructions are generated and can specify the instructions that should be executed at the beginning (<code>pre_ixs</code>), in the middle (<code>ixs</code>) and at the end (<code>post_ixs</code>) of each iteration. This can be useful for example if your program needs an initialization or you want to fuzz some specific program state.</li> </ol> </li> <li>For each instruction:<ol> <li>User defined mandatory method <code>get_accounts()</code> is called to collect necessary instruction accounts.</li> <li>User defined mandatory method <code>get_data()</code> is called to collect instruction data.</li> <li>A snapshot of all instruction accounts before the instruction execution is saved.</li> <li>The instruction is executed.</li> <li>A snapshot of all instruction accounts after the instruction execution is saved.</li> <li>User defined optional method <code>check()</code> is called to check accounts data and evaluate invariants.</li> </ol> </li> </ol> fuzzer_iterations = 0fuzzer_iterations = 0fuzzer_iterations &lt;\u00a0max_iterationsfuzzer_iterations &lt;...donedonecreate pre-instruction\u00a0accounts snapshotscreate pre-instruction...execute instructionexecute instructioncreate post-instruction\u00a0accounts snapshotscreate post-instruction...check invariants \ud83d\udc64check invariants \ud83d\udc64fuzzer_iterations++fuzzer_iterations++Generate instructionspre_ixs \ud83d\udc64pre_ixs \ud83d\udc64ixs \ud83d\udc64ixs \ud83d\udc64post_ixs \ud83d\udc64post_ixs \ud83d\udc64endendfor ix in instructionsfor ix in instructionsget instruction accounts \u26a1get instruction accounts \u26a1get instruction data \u26a1get instruction data \u26a1next ixnext ixText is not SVG - cannot display"},{"location":"fuzzing/first-steps/fuzz-test-initialization/","title":"Initialize Fuzz Test","text":"<p>For initialization of workspace for fuzz tests, call: <pre><code>trident init fuzz\n</code></pre></p> <p>The command will generate the following folder structure: <pre><code>project-root\n\u251c\u2500\u2500 trident-tests\n\u2502   \u251c\u2500\u2500 fuzz_tests # fuzz tests folder\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_0 # particular fuzz test\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 accounts_snapshots.rs # generated accounts deserialization methods\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test_fuzz.rs # the binary target of your fuzz test\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fuzz_instructions.rs # the definition of your fuzz test\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_1\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_X # possible multiple fuzz tests\n\u2502   \u2502   \u251c\u2500\u2500 fuzzing # compilations and crashes folder\n\u2502   \u2502   \u2514\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 Trident.toml\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"fuzzing/first-steps/fuzz-test-initialization/#add-new-fuzz-test","title":"Add new Fuzz Test","text":"<p>If you wish to generate template for a new fuzz test, call: <pre><code>trident fuzz add\n</code></pre></p>"},{"location":"fuzzing/first-steps/writing-fuzz-test/","title":"Writing Fuzz Test","text":"<p>Important</p> <p>At the current development stage, there are some manual steps required to start the Fuzzing Session. In principle:</p> <p>Prerequisites:</p> <ul> <li>Add dependencies specific to your program to <code>trident-tests/fuzz_tests/Cargo.toml</code> (such as anchor-spl etc.).</li> <li>Add necessary <code>use</code> statements into <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/accounts_snapshots.rs</code> to import missing types.</li> </ul> <p>Writing Fuzz Tests</p> <ol> <li>Include desired Programs Include Programs.</li> <li>Specify pseudo-random accounts to re-use Accounts to re-use.</li> <li>Specify instruction data Instruction Data.</li> <li>Specify instruction accounts Instruction Accounts.</li> </ol> <p>Run and Debug</p> <ol> <li>Execute desired fuzz test Run</li> <li>See the found crash with more details Debug</li> </ol> <p>Note</p> <p>For better fuzzing results and experience you can also manually adjust the following:</p> <ol> <li>Define Invariants checks Invariants Checks.</li> <li>Specify instruction sequences Instruction sequences.</li> <li>Specify custom data types Custom Data types.</li> <li>Well structured data Arbitrary.</li> <li>AccountsSnapshots macro AccountsSnapshots.</li> </ol>"},{"location":"fuzzing/writing-fuzz-test/accounts/","title":"Accounts to reuse","text":"<p>Trident helps you to generate only a limited amount of pseudo-random accounts and reuse them in the instructions.</p> Note <p>Details:</p> <p>Always generating only random accounts would in most cases lead to a situation where the fuzzer would be stuck because the accounts would be almost every time rejected by your Anchor program. Therefore it is necessary to specify, what accounts should be used and also limit the number of newly created accounts to reduce the space complexity.</p> <p>Important</p> <p>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>FuzzAccounts</code> structure. It contains all accounts used in your program. You have to determine if the account is a:</p> <ul> <li>Signer</li> <li>PDA</li> <li>Token Account</li> <li>Program account</li> </ul> <p>Then use the corresponding AccountsStorage.</p> <pre><code>pub struct FuzzAccounts {\n    signer: AccountsStorage&lt;Keypair&gt;,\n    some_pda: AccountsStorage&lt;PdaStore&gt;,\n    token_vault: AccountsStorage&lt;TokenStore&gt;,\n    mint: AccountsStorage&lt;MintStore&gt;,\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"fuzzing/writing-fuzz-test/instruction-accounts/","title":"Instruction accounts","text":"<p>Trident generates random indexes of accounts to use in each instruction. Each created account is saved in the global FuzzAccounts structure which helps you to reuse already existing accounts across all instructions.</p> <p>Important</p> <p>You are required to define, how these accounts should be created and which accounts should be passed to an instruction. It is done using the <code>IxOps</code> trait and its method <code>get_accounts</code>.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>get_accounts</code> methods for each instruction.</li> </ul> <pre><code>fn get_accounts(\n    &amp;self,\n    client: &amp;mut impl FuzzClient,\n    fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;(Vec&lt;Keypair&gt;, Vec&lt;AccountMeta&gt;), FuzzingError&gt; {\n    let author = fuzz_accounts.author.get_or_create_account(\n        self.accounts.author,\n        client,\n        5000000000000,\n    );\n    let signers = vec![author.clone()];\n    let state = fuzz_accounts\n        .state\n        .get_or_create_account(\n            self.accounts.state,\n            &amp;[author.pubkey().as_ref(), STATE_SEED.as_ref()],\n            &amp;fuzz_example1::ID,\n        )\n        .ok_or(FuzzingError::CannotGetAccounts)?\n        .pubkey();\n    let acc_meta = fuzz_example1::accounts::EndRegistration {\n        author: author.pubkey(),\n        state,\n    }\n    .to_account_metas(None);\n    Ok((signers, acc_meta))\n}\n</code></pre> <p>Note</p> <p>Notice especially the helper method <code>fuzz_accounts.&lt;account_name&gt;.get_or_create_account</code> that is used to create a Keypair or retrieve the Public key of the already existing account.</p>"},{"location":"fuzzing/writing-fuzz-test/instruction-accounts/#create-an-arbitrary-account","title":"Create an arbitrary account","text":"<p>The <code>AccountsStorage&lt;T&gt;</code> type provides an implementation of the <code>get_or_create_account</code> method that helps you create new or read already existing accounts. There are different implementations for different types of storage (<code>Keypair</code>, <code>TokenStore</code>, <code>MintStore</code>, <code>PdaStore</code>) to simplify the creation of new accounts.</p> <p>However, there are cases when the provided implementation is not sufficient and it is necessary to create an account manually. These cases can be (but are not limited to) for example:</p> <ul> <li>you need to create a new account with a predefined address</li> <li>you need to create a new account that is not owned by the system program</li> <li>you need to create and initialize a new PDA account</li> <li>your program expects an account to be initialized in a previous instruction</li> </ul> <p>In that case, you can use the <code>storage</code> method of the <code>AccountsStorage&lt;T&gt;</code> struct that exposes the underlying <code>HashMap&lt;AccountId, T&gt;</code> and you can add new accounts directly to it.</p> <p>It is possible to create and store any kind of account. For example:</p> <ul> <li>to add an account that uses the <code>#[account(zero)]</code> anchor constraint (must be rent exempt, owned by your program, with empty data):</li> </ul> <pre><code>let state = fuzz_accounts\n    .state\n    // gets the storage of all `state` account variants\n    .storage()\n    // returns the Keypair of the `state` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.state)\n    .or_insert_with(|| {\n        let space = State::SIZE;\n        let rent_exempt_lamports = client.get_rent().unwrap()\n                            .minimum_balance(space);\n        let keypair = Keypair::new();\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_lamports,\n            &amp;[],\n            space,\n            &amp;my_program::id(),\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;keypair.pubkey(), &amp;account);\n        keypair\n    });\n</code></pre> <ul> <li>to add a new system-owned account with a specific PDA (address):</li> </ul> <pre><code>let rent_exempt_for_token_acc = client\n    .get_rent()\n    .unwrap()\n    .minimum_balance(anchor_spl::token::spl_token::state::Account::LEN);\n\nlet my_pda = fuzz_accounts\n    .my_pda\n    // gets the storage of all `my_pda` account variants\n    .storage()\n    // returns the PdaStore struct of the `my_pda` account with\n    // the given `AccountId` if it has been added previously\n    .entry(self.accounts.my_pda)\n    .or_insert_with(|| {\n        let seeds = &amp;[b\"some-seeds\"];\n        let pda = Pubkey::find_program_address(seeds, &amp;my_program::id()).0;\n        let account = AccountSharedData::new_data_with_space::&lt;[u8; 0]&gt;(\n            rent_exempt_for_token_acc,\n            &amp;[],\n            0,\n            &amp;SYSTEM_PROGRAM_ID,\n        ).unwrap();\n        // insert the custom account also into the client\n        client.set_account_custom(&amp;pda, &amp;account);\n        let vec_of_seeds: Vec&lt;Vec&lt;u8&gt;&gt; = seeds.iter().map(|&amp;seed| seed.to_vec())\n                            .collect();\n        PdaStore {\n            pubkey: pda,\n            seeds: vec_of_seeds,\n        }\n    }).pubkey();\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test/instruction-accounts/#example","title":"Example","text":"<p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"fuzzing/writing-fuzz-test/instruction-data/","title":"Instruction data","text":"<p>Trident generates random instruction data for you.</p> <p>Important</p> <p>Currently, it is however required, that you manually assign the random fuzzer data to the instruction data. It is done using the <code>IxOps</code> trait and its method <code>get_data</code>.</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/fuzz_instructions.rs</code> file and complete the pre-generated <code>get_data</code> methods for each instruction.</li> </ul> <pre><code>fn get_data(\n    &amp;self,\n    _client: &amp;mut impl FuzzClient,\n    _fuzz_accounts: &amp;mut FuzzAccounts,\n) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n    let data = fuzz_example1::instruction::Invest {\n        amount: self.data.amount,\n    };\n    Ok(data)\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"fuzzing/writing-fuzz-test/programs/","title":"Include Programs","text":"<p>With Trident you can and need to specify which programs will be included in the Testing Environment.</p> <p>Important</p> <p>As Trident supports Cross-Program Invocations you need to specify all of the programs that the Solana Environment should start with, same as for the ProgramTest. Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/test_fuzz.rs</code> and customize the Solana Environment as shown below.</p> <pre><code>// use statements ...\nuse ... as FuzzInstruction_hello_world;\n\nuse hello_world::entry as entry_hello_world;\nuse hello_world::ID as PROGRAM_ID_HELLO_WORLD;\nconst PROGRAM_NAME_HELLO_WORLD: &amp;str = \"hello_world\";\n\n// TODO specify this type for Instructions generation.\npub type FuzzInstruction = FuzzInstruction_hello_world;\n\nstruct MyFuzzData;\n\nimpl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {}\n\nfn main() {\n    loop {\n        fuzz_trident!(fuzz_ix: FuzzInstruction, |fuzz_data: MyFuzzData| {\n\n            // Include the program and its entrypoint in the Testing Environment\n            let fuzzing_program1 = FuzzingProgram::new(\n                PROGRAM_NAME_HELLO_WORLD,\n                &amp;PROGRAM_ID_HELLO_WORLD,\n                processor!(convert_entry!(entry_hello_world))\n            );\n\n            let mut client =\n                ProgramTestClientBlocking::new(\n                    &amp;[fuzzing_program1]\n                ).unwrap();\n\n            // fill Program ID of program you are going to call\n            let _ = fuzz_data.run_with_runtime(\n                PROGRAM_ID_HELLO_WORLD,\n                &amp;mut client\n            );\n        });\n    }\n}\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test/programs/#sbf","title":"SBF","text":"<p>Important</p> <p>If you want to include Solana Programs from some of the clusters (for example Mainnet). Follow these steps:</p> <ol> <li>Dump the program from the desired cluster (<code>solana program dump -u m &lt;PROGRAM_ID&gt; &lt;PROGRAM_NAME&gt;.so</code>).</li> <li>Create folder <code>trident-genesis</code> in the root of the Anchor Workspace (i.e. next to the Anchor.toml)</li> <li>Copy the dumped file to the <code>trident-genesis</code>.</li> <li>Include the program as described below.</li> </ol> <p>Warning</p> <p>The name of the dumped .so file has to be the same as the program name you are including (i.e. you are including metaplex-token-metadata, then the file name has to be metaplex-token-metadata.so)</p> <pre><code>// use statements ...\nuse ... as FuzzInstruction_hello_world;\n\nuse hello_world::entry as entry_hello_world;\nuse hello_world::ID as PROGRAM_ID_HELLO_WORLD;\nconst PROGRAM_NAME_HELLO_WORLD: &amp;str = \"hello_world\";\n\n// TODO specify this type for Instructions generation.\npub type FuzzInstruction = FuzzInstruction_hello_world;\n\nstruct MyFuzzData;\n\nimpl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {}\n\nfn main() {\n    loop {\n        fuzz_trident!(fuzz_ix: FuzzInstruction, |fuzz_data: MyFuzzData| {\n\n            // Include the program and its entrypoint in the Testing Environment\n            let fuzzing_program1 = FuzzingProgram::new(\n                PROGRAM_NAME_CPI_METAPLEX_7,\n                &amp;PROGRAM_ID_CPI_METAPLEX_7,\n                processor!(convert_entry!(entry_cpi_metaplex_7))\n            );\n\n\n            let metaplex = FuzzingProgram::new(\n                \"metaplex-token-metadata\",\n                &amp;mpl_token_metadata::ID,\n                None\n            );\n\n            let mut client =\n                ProgramTestClientBlocking::new(&amp;[fuzzing_program1,metaplex])\n                    .unwrap();\n\n            // fill Program ID of program the fuzzer will call.\n            let _ = fuzz_data.run_with_runtime(\n                PROGRAM_NAME_PROGRAM_1,\n                &amp;mut client\n            );\n        });\n    }\n}\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test/programs/#native","title":"Native","text":"<p>Important</p> <p>If you want to include additional Solana programs within the Testing Environment for example for CPI purposes you can include them with the same approach as including only one program. More details in the snippet below.</p> <pre><code>// use statements ...\nuse ... as FuzzInstruction_program1;\nuse ... as FuzzInstruction_program2;\n\n\nuse program1::entry as entry_program1;\nuse program1::ID as PROGRAM_ID_PROGRAM_1;\nconst PROGRAM_NAME_PROGRAM_1: &amp;str = \"program1\";\n\nuse program2::entry as entry_program2;\nuse program2::ID as PROGRAM_ID_PROGRAM_2;\nconst PROGRAM_NAME_PROGRAM_2: &amp;str = \"program2\";\n\n\n// TODO specify this type for Instructions generation.\n// These instructions are going to be called by the Fuzzer\npub type FuzzInstruction = FuzzInstruction_program1;\n\nstruct MyFuzzData;\n\nimpl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {}\n\nfn main() {\n    loop {\n        fuzz_trident!(fuzz_ix: FuzzInstruction, |fuzz_data: MyFuzzData| {\n\n            // Include the program and its entrypoint in the Testing Environment\n            let fuzzing_program1 = FuzzingProgram::new(\n                PROGRAM_NAME_PROGRAM_1,\n                &amp;PROGRAM_ID_PROGRAM_1,\n                processor!(convert_entry!(entry_program1))\n            );\n\n            let fuzzing_program2 = FuzzingProgram::new(\n                PROGRAM_NAME_PROGRAM_2,\n                &amp;PROGRAM_ID_PROGRAM_2,\n                processor!(convert_entry!(entry_program2))\n            );\n\n\n            let mut client =\n                ProgramTestClientBlocking::new(\n                    &amp;[fuzzing_program1,fuzzing_program2]\n                ).unwrap();\n\n            // fill Program ID of program the fuzzer will call.\n            let _ = fuzz_data.run_with_runtime(\n                PROGRAM_NAME_PROGRAM_1,\n                &amp;mut client\n            );\n        });\n    }\n}\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test/programs/#example","title":"Example","text":"<p>Tip</p> <p>For a practical example of CPI, please refer to the Examples section.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/","title":"AccountsSnapshots","text":"<p>Trident provides AccountsSnapshots macro that can be derived for each Instruction Context you have specified in your Solana Program for real-time updates of the Instruction Context.</p> <p>Important</p> <p>AccountsSnapshots macro requires additional deps and source code additions in your Solana Program. On the other hand can provide real-time updates of Context modifications, instead of re-generating the <code>accounts_snapshots.rs</code>.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#add-required-imports","title":"Add required imports","text":"<p>To the Cargo.toml of the Solana Program add the following feature and deps.</p> <pre><code>[package]\nname = \"...\"\nversion = \"0.1.0\"\ndescription = \"Created with Anchor\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\", \"lib\"]\nname = \"...\"\n\n[features]\ndefault = []\ncpi = [\"no-entrypoint\"]\nno-entrypoint = []\nno-idl = []\nno-log-ix-name = []\nidl-build = [\"anchor-lang/idl-build\", \"anchor-spl/idl-build\"]\n# add the feature below\n# ---\ntrident-fuzzing = [\"dep:trident-fuzz\"]\n# ---\n\n\n[dependencies]\n# ---\n# add the following Trident deps with the desired version\ntrident-derive-accounts-snapshots = \"...\"\ntrident-fuzz = { version = \"...\", optional = true }\n# ---\n# Your deps\nanchor-lang = \"0.30.1\"\nanchor-spl = \"0.30.1\"\n...\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#derive-the-accountssnapshots","title":"Derive the AccountsSnapshots","text":"<p>For each context in your program you can derive the AccountsSnapshots.</p> <pre><code>use trident_derive_accounts_snapshots::AccountsSnapshots;\n\n// ...\n\n#[derive(AccountsSnapshots, Accounts)]\npub struct TheContextName&lt;'info&gt; {\n    #[account(...)]\n    pub account1: ...&lt;'info&gt;,\n\n    #[account(...)]\n    pub account2: ...&lt;'info, ...&gt;,\n\n    #[account(\n        ...\n     )]\n    pub account3: ...,\n\n    // additional accounts\n}\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#use-accountssnapshots-in-the-fuzz-tests","title":"Use AccountsSnapshots in the Fuzz Tests","text":""},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#use-defined-feature","title":"Use defined feature","text":"<p>In the Cargo.toml within the <code>trident-tests/fuzz_tests</code>. Activate the new feature next to the program dependency.</p> <pre><code>[dependencies.&lt;PROGRAM_NAME&gt;]\npath = \"../../programs/&lt;PROGRAM_NAME&gt;\"\nfeatures = [\"trident-fuzzing\"]\n</code></pre>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#use-the-derived-accountssnapshots-within-the-fuzz-test","title":"Use the derived AccountsSnapshots within the Fuzz Test","text":"<p>Now you can use the derived AccountsSnapshots within the Fuzz Test instead of using generated <code>accounts_snapshots.rs</code>.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/accounts-snapshots/#example","title":"Example","text":"<p>Tip</p> <p>Check the Fuzz Example that uses the AccountsSnapshots macro.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/arbitrary/","title":"Structured Data","text":"<p>The Arbitrary crate in Rust is used for generating well-typed, structured instances of data from raw byte buffers, making it useful for fuzzing by producing random but structured data for tests.</p> <p>By implementing the Arbitrary trait for Instruction Data structures, you can guide the fuzzing tool to generate meaningful instances of these structures, thus ensuring a more effective and targeted fuzzing process.</p> <p>Let`s say your Solana program contains instruction, with a similar logic as the example below: <pre><code>#[program]\npub mod your_program {\n    pub fn init_vesting(\n        ctx: Context&lt;InitVesting&gt;,\n        recipient: Pubkey,\n        amount: u64,\n        start_at: u64,\n        end_at: u64,\n        interval: u64,\n    ) -&gt; Result&lt;()&gt; {\n        _init_vesting(ctx, recipient, amount, start_at, end_at, interval)\n    }\n}\n...\npub fn _init_vesting(\n    ctx: Context&lt;InitVesting&gt;,\n    recipient: Pubkey,\n    amount: u64,\n    start_at: u64,\n    end_at: u64,\n    interval: u64,\n) -&gt; Result&lt;()&gt; {\n    ...\n    // the Instruction Data arguments are not completely random\n    // and should have the following restrictions\n    require!(amount &gt; 0, VestingError::InvalidAmount);\n    require!(end_at &gt; start_at, VestingError::InvalidTimeRange);\n    require!(end_at - start_at &gt; interval, VestingError::InvalidInterval);\n    require!(interval &gt; 0, VestingError::InvalidInterval);\n    ...\n\n}\n</code></pre></p> <p>For this purpose, you can limit the generated Instruction Data structure that is sent to the instruction by the fuzzer, in the following ways</p>"},{"location":"fuzzing/writing-fuzz-test-extra/arbitrary/#customizing-single-fields","title":"Customizing single fields","text":"<p>You can limit the generated Instruction Input Data by customizing particular fields, Check Customizing single fields for more details.</p> <p>For the example specified above, with the customization we can limit the particular fields such that <pre><code>// Instruction Data structure automatically generated\n// inside fuzz_instructions.rs\n...\n#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    // specify the range for amount\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1_000_000)\n    )]\n    pub amount: u64,\n    // specify the range for start_at , this way it will\n    // be always smaller than end_at\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(0..=1_000_000)\n    )]\n    pub start_at: u64,\n    // specify the range for end_at\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured|\n        u.int_in_range(1_001_001..=1_050_000)\n    )]\n    pub end_at: u64,\n    // specify the range for interval\n    #[arbitrary(\n        with = |u: &amp;mut arbitrary::Unstructured| u.int_in_range(1..=1000)\n    )]\n    pub interval: u64,\n}\n...\n</code></pre></p>"},{"location":"fuzzing/writing-fuzz-test-extra/arbitrary/#implementing-arbitrary-by-hand","title":"Implementing Arbitrary By Hand","text":"<p>Alternatively, you can write Arbitrary implementation by yourself. <pre><code>// for the given example above, this structure is automatically generated\n// with the fuzzer inside fuzz_instructions.rs\n#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n}\n</code></pre></p> <p>Now, instead of using an automatically derived Arbitrary trait, you can implement the trait by hand <pre><code>...\n#[derive(Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n}\nimpl&lt;'a&gt; Arbitrary&lt;'a&gt; for InitVestingData {\n    fn arbitrary(\n        u: &amp;mut arbitrary::Unstructured&lt;'a&gt;\n    ) -&gt; arbitrary::Result&lt;Self&gt; {\n        // obtain AccountId\n        let recipient = AccountId::arbitrary(u)?;\n\n        // limit the generated amount to the 1_000_000\n        let amount = u.int_in_range(1..=1_000_000)?;\n\n        // now we want to obtain\n        // - start_at\n        // - end_at\n        // - interval\n        // however we want to limit the data such that:\n        // - start_at &lt; end_at\n        // - end_at - start_at &gt; interval\n        // - interval has lower limit of 500 and upper limit of 1000.\n\n        let start_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let end_at: u64 = u.int_in_range(1_000_000..=5_000_000)?;\n        let interval: u64 = u.int_in_range(500..=1000)?;\n\n        // ensure that start_at &lt; end_at\n        if start_at &gt;= end_at {\n            return Err(arbitrary::Error::IncorrectFormat);\n        }\n\n        // ensure that end_at - start_at &gt; interval\n        match end_at.checked_sub(start_at) {\n            Some(diff) =&gt; {\n                if diff &lt;= interval {\n                    return Err(arbitrary::Error::IncorrectFormat);\n                }\n            }\n            None =&gt; return Err(arbitrary::Error::IncorrectFormat),\n        }\n\n        Ok(InitVestingData {\n            recipient,\n            amount,\n            start_at,\n            end_at,\n            interval,\n        })\n    }\n}\n...\n</code></pre></p>"},{"location":"fuzzing/writing-fuzz-test-extra/arbitrary/#example","title":"Example","text":"<p>Tip</p> <p>For a practical example, please refer to the Examples section.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/custom-data-types/","title":"Custom Data Types","text":"<p>If you use Custom Types as Instruction data arguments, you may encounter a problem that the Custom Type does not implement</p> <ul> <li>Debug trait</li> <li>Arbitrary trait</li> </ul> <p>For example: <pre><code>#[program]\npub mod your_program {\n    pub fn init_vesting(\n            ctx: Context&lt;InitVesting&gt;,\n            recipient: Pubkey,\n            amount: u64,\n            start_at: u64,\n            end_at: u64,\n            interval: u64,\n            // Custom Type input argument\n            _input_variant: CustomEnumInput,\n    ) -&gt; Result&lt;()&gt; {\n        _init_vesting(ctx, recipient, amount, start_at, end_at, interval)\n    }\n}\n\n...\n\n#[derive(AnchorDeserialize, AnchorSerialize)]\npub enum CustomEnumInput {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p> <p>Then inside the <code>fuzz_instructions.rs</code>, you may see:</p> <pre><code>#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n    /// IMPORTANT:\n    /// your_program::CustomEnumInput does not derive\n    /// Arbitrary, nor Debug trait\n    pub _input_variant: your_program::CustomEnumInput,\n}\n</code></pre> <p>To resolve this issue, you have two options.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/custom-data-types/#derive-debug-and-arbitrary-traits-inside-your-program","title":"Derive Debug and Arbitrary traits inside your program","text":"<p>This option necessitates updating the source code of your on-chain program, which might be undesirable. If you prefer not to modify your program, consider the alternative option provided below.</p> <p>Inside <code>programs/&lt;YOUR_PROGRAM&gt;/Cargo.toml</code> file include: <pre><code>...\n[dependencies]\n...\narbitrary = { version = \"1.3.0\", features = [\"derive\"] }\n...\n</code></pre></p> <p>and within the program source code: <pre><code>// derive Debug, Arbitrary\n#[derive(AnchorDeserialize, AnchorSerialize, Debug, Arbitrary)]\npub enum CustomEnumInput {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p>"},{"location":"fuzzing/writing-fuzz-test-extra/custom-data-types/#derive-debug-and-arbitrary-traits-inside-the-fuzz-test","title":"Derive Debug and Arbitrary traits inside the Fuzz Test","text":"<p>You can redefine the custom type within the <code>fuzz_instructions.rs</code> file, along with all the necessary traits. <pre><code>// Redefine the Custom Type inside the fuzz_instructions.rs,\n// but this time with all of the required traits.\n#[derive(Arbitrary,Debug, Clone, Copy)]\npub enum CustomEnumInputFuzz {\n    InputVariant1,\n    InputVariant2,\n    InputVariant3,\n}\n</code></pre></p> <p>And instead of using the input argument defined within the program, you should modify it as follows: <pre><code>#[derive(Arbitrary, Debug)]\npub struct InitVestingData {\n    pub recipient: AccountId,\n    pub amount: u64,\n    pub start_at: u64,\n    pub end_at: u64,\n    pub interval: u64,\n    /// IMPORTANT:\n    /// redefined Custom Type\n    pub _input_variant: CustomEnumInputFuzz,\n}\n</code></pre></p> <p>Then, you would also need to implement the <code>std::convert::From&lt;T&gt;</code> trait to enable conversion between the newly defined Custom Type and the Custom Type used within your program. <pre><code>// implement std::convert::From to convert between CustomEnumInputFuzz\n// and your_program::CustomEnumInput as these are distinc Data Types.\nimpl std::convert::From&lt;CustomEnumInputFuzz&gt; for your_program::CustomEnumInput {\n    fn from(val: CustomEnumInputFuzz) -&gt; Self {\n        match val {\n            CustomEnumInputFuzz::InputVariant1 =&gt; {\n                your_program::CustomEnumInput::InputVariant1\n            }\n            CustomEnumInputFuzz::InputVariant2 =&gt; {\n                your_program::CustomEnumInput::InputVariant2\n            }\n            CustomEnumInputFuzz::InputVariant3 =&gt; {\n                your_program::CustomEnumInput::InputVariant3\n            }\n        }\n    }\n}\n</code></pre> Finally, within the <code>get_data</code> function, you can proceed as follows: <pre><code>impl&lt;'info&gt; IxOps&lt;'info&gt; for InitVestingData {\n    ...\n    fn get_data(\n        &amp;self,\n        _client: &amp;mut impl FuzzClient,\n        _fuzz_accounts: &amp;mut FuzzAccounts,\n    ) -&gt; Result&lt;Self::IxData, FuzzingError&gt; {\n        // cast variable into correct Data Type\n        let variant = self.data._input_variant.into();\n\n        let data = your_program::instruction::InitVestingData {\n        ...\n        _input_variant:variant,\n        ...\n        };\n        Ok(data)\n    }\n    ...\n}\n</code></pre></p>"},{"location":"fuzzing/writing-fuzz-test-extra/custom-data-types/#example","title":"Example","text":"<p>Tip</p> <p>For a practical example, please refer to the Examples section.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/instruction-sequences/","title":"Instruction sequences","text":"<p>It is possible to customize how the instructions are generated and which instructions will be executed at the beginning (<code>pre_ixs</code>), in the middle (<code>ixs</code>) and at the end (<code>post_ixs</code>) of each fuzz iteration. This can be useful for example if your program needs an initialization or you want to fuzz some specific program state.</p> <p>Important</p> <ul> <li>Go to the <code>trident-tests/fuzz_tests/&lt;FUZZ_TEST_NAME&gt;/test_fuzz.rs</code> and implement the corresponding optional method of the <code>FuzzDataBuilder&lt;FuzzInstruction&gt;</code> trait. For example, in order to always call the <code>initialize</code> instruction, modify the trait's implementation.</li> </ul> <pre><code>impl FuzzDataBuilder&lt;FuzzInstruction&gt; for MyFuzzData {\n    fn pre_ixs(u: &amp;mut arbitrary::Unstructured) -&gt;\n        arbitrary::Result&lt;Vec&lt;FuzzInstruction&gt;&gt; {\n        let init_ix = FuzzInstruction::Initialize(Initialize::arbitrary(u)?);\n        Ok(vec![init_ix])\n    }\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"fuzzing/writing-fuzz-test-extra/invariants-checks/","title":"Invariants checks","text":"<p>After each successful instruction execution, the <code>check()</code> method is called to check the account data invariants.</p> <p>Important</p> <p>For each instruction, you can compare the account data before and after the instruction execution.</p> <pre><code>fn check(\n    &amp;self,\n    pre_ix: Self::IxSnapshot,\n    post_ix: Self::IxSnapshot,\n    _ix_data: Self::IxData,\n) -&gt; Result&lt;(), &amp;'static str&gt; {\n    if let Some(escrow_pre) = pre_ix.escrow {\n        // we can unwrap the receiver account because it\n        // has to be initialized before the instruction\n        // execution and it is not supposed to be closed\n        // after the instruction execution either\n        let receiver = pre_ix.receiver.unwrap();\n        let receiver_lamports_before = receiver.lamports();\n        let receiver_lamports_after = post_ix.receiver.unwrap().lamports();\n\n        if receiver.key() != escrow_pre.receiver.key()\n            &amp;&amp; receiver_lamports_before &lt; receiver_lamports_after\n        {\n            return Err(\"Un-authorized withdrawal\");\n        }\n    }\n\n    Ok(())\n}\n</code></pre> <p>Tip</p> <p>Consider checking the Examples section for more tips.</p>"},{"location":"getting-started/docker-image/","title":"Docker Image","text":"<p>TBD</p>"},{"location":"getting-started/getting-started/","title":"Installation","text":"<p>This guide will walk you through the Installation process of Trident.</p> <p>Important</p> <p>Prerequisite</p> <p>It is expected that you have installed:</p> <ul> <li>Rust (Install Rust)</li> <li>Solana CLI (Install Solana CLI)</li> <li>Anchor Framework (Install Anchor)</li> </ul> <p>For supported versions check the Supported Versions</p>"},{"location":"getting-started/getting-started/#install-system-dependencies","title":"Install System Dependencies","text":"<p>Update your package list and install the required packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y \\\n    curl \\\n    git \\\n    build-essential \\\n    pkg-config \\\n    libssl-dev \\\n    npm \\\n    vim \\\n    nano \\\n    wget \\\n    binutils-dev \\\n    libunwind-dev \\\n    lldb\n</code></pre>"},{"location":"getting-started/getting-started/#install-trident-and-honggfuzz","title":"Install Trident and Honggfuzz","text":"<p>Install them using the following commands:</p> <pre><code>cargo install trident-cli\ncargo install honggfuzz\n</code></pre>"},{"location":"getting-started/getting-started/#supported-versions","title":"Supported versions","text":"Trident CLI Anchor Solana Rust Honggfuzz <code>v0.7.0</code> <code>&gt;=0.29.*</code><sup>1</sup> <code>^1.17.4</code> <code>nightly</code> <code>0.5.56</code> <code>v0.6.0</code> <code>&gt;=0.29.*</code><sup>1</sup> <code>^1.17</code> <code>nightly</code> <code>0.5.55</code> <code>v0.5.0</code> <code>~0.28.*</code> <code>=1.16.6</code> - - <code>v0.4.0</code> <code>~0.27.*</code> <code>&gt;=1.15</code> - - <code>v0.3.0</code> <code>~0.25.*</code> <code>&gt;=1.10</code> - - <code>v0.2.0</code> <code>~0.24.*</code> <code>&gt;=1.9</code> - - <ol> <li>To use Trident with Anchor 0.29.0, run the following commands from your project's root directory after Trident initialization: <pre><code>cargo update anchor-client@0.30.0 --precise 0.29.0\ncargo update anchor-spl@0.30.0 --precise 0.29.0\n</code></pre></li> </ol>"}]}