//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: maze
// ----------------------------------------------------------------------------
pub mod maze {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for maze
    pub fn program_id() -> Pubkey {
        pubkey!("5e554BrmQN7a2nbKrSUUxP8PMbq55rMntnkoCPmwr3Aq")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {
        pub state_author: AccountMeta,

        pub state: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {
        pub state_author: Pubkey,

        pub state: Pubkey,
    }

    impl InitializeInstructionAccounts {
        pub fn new(state_author: Pubkey, state: Pubkey) -> Self {
            Self {
                state_author,

                state,
            }
        }
    }

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {}

    impl InitializeInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self.accounts.state_author = AccountMeta::new(accounts.state_author, true);

            self.accounts.state = AccountMeta::new(accounts.state, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.state_author.clone());

            metas.push(self.accounts.state.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MoveEast
    // ....................................................................

    /// Main instruction struct for MoveEast
    pub struct MoveEastInstruction {
        pub accounts: MoveEastInstructionAccountMetas,
        pub data: MoveEastInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MoveEast instruction
    #[derive(Debug, Clone, Default)]
    pub struct MoveEastInstructionAccountMetas {
        pub state: AccountMeta,
    }

    /// Account pubkeys for MoveEast instruction
    #[derive(Debug, Clone)]
    pub struct MoveEastInstructionAccounts {
        pub state: Pubkey,
    }

    impl MoveEastInstructionAccounts {
        pub fn new(state: Pubkey) -> Self {
            Self { state }
        }
    }

    /// Instruction data for MoveEast
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MoveEastInstructionData {
        pub p0: u64,

        pub p1: u64,

        pub p2: u64,

        pub p3: u64,

        pub p4: u64,

        pub p5: u64,

        pub p6: u64,

        pub p7: u64,
    }

    impl MoveEastInstructionData {
        pub fn new(p0: u64, p1: u64, p2: u64, p3: u64, p4: u64, p5: u64, p6: u64, p7: u64) -> Self {
            Self {
                p0,

                p1,

                p2,

                p3,

                p4,

                p5,

                p6,

                p7,
            }
        }
    }

    /// Implementation for MoveEastInstruction
    impl MoveEastInstruction {
        fn discriminator() -> [u8; 8] {
            [220u8, 96u8, 254u8, 139u8, 6u8, 133u8, 127u8, 93u8]
        }

        pub fn data(data: MoveEastInstructionData) -> Self {
            Self {
                accounts: MoveEastInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MoveEastInstructionAccounts) -> Self {
            self.accounts.state = AccountMeta::new(accounts.state, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.state.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MoveNorth
    // ....................................................................

    /// Main instruction struct for MoveNorth
    pub struct MoveNorthInstruction {
        pub accounts: MoveNorthInstructionAccountMetas,
        pub data: MoveNorthInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MoveNorth instruction
    #[derive(Debug, Clone, Default)]
    pub struct MoveNorthInstructionAccountMetas {
        pub state: AccountMeta,
    }

    /// Account pubkeys for MoveNorth instruction
    #[derive(Debug, Clone)]
    pub struct MoveNorthInstructionAccounts {
        pub state: Pubkey,
    }

    impl MoveNorthInstructionAccounts {
        pub fn new(state: Pubkey) -> Self {
            Self { state }
        }
    }

    /// Instruction data for MoveNorth
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MoveNorthInstructionData {
        pub p0: u64,

        pub p1: u64,

        pub p2: u64,

        pub p3: u64,

        pub p4: u64,

        pub p5: u64,

        pub p6: u64,

        pub p7: u64,
    }

    impl MoveNorthInstructionData {
        pub fn new(p0: u64, p1: u64, p2: u64, p3: u64, p4: u64, p5: u64, p6: u64, p7: u64) -> Self {
            Self {
                p0,

                p1,

                p2,

                p3,

                p4,

                p5,

                p6,

                p7,
            }
        }
    }

    /// Implementation for MoveNorthInstruction
    impl MoveNorthInstruction {
        fn discriminator() -> [u8; 8] {
            [65u8, 4u8, 235u8, 142u8, 120u8, 215u8, 181u8, 131u8]
        }

        pub fn data(data: MoveNorthInstructionData) -> Self {
            Self {
                accounts: MoveNorthInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MoveNorthInstructionAccounts) -> Self {
            self.accounts.state = AccountMeta::new(accounts.state, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.state.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MoveSouth
    // ....................................................................

    /// Main instruction struct for MoveSouth
    pub struct MoveSouthInstruction {
        pub accounts: MoveSouthInstructionAccountMetas,
        pub data: MoveSouthInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MoveSouth instruction
    #[derive(Debug, Clone, Default)]
    pub struct MoveSouthInstructionAccountMetas {
        pub state: AccountMeta,
    }

    /// Account pubkeys for MoveSouth instruction
    #[derive(Debug, Clone)]
    pub struct MoveSouthInstructionAccounts {
        pub state: Pubkey,
    }

    impl MoveSouthInstructionAccounts {
        pub fn new(state: Pubkey) -> Self {
            Self { state }
        }
    }

    /// Instruction data for MoveSouth
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MoveSouthInstructionData {
        pub p0: u64,

        pub p1: u64,

        pub p2: u64,

        pub p3: u64,

        pub p4: u64,

        pub p5: u64,

        pub p6: u64,

        pub p7: u64,
    }

    impl MoveSouthInstructionData {
        pub fn new(p0: u64, p1: u64, p2: u64, p3: u64, p4: u64, p5: u64, p6: u64, p7: u64) -> Self {
            Self {
                p0,

                p1,

                p2,

                p3,

                p4,

                p5,

                p6,

                p7,
            }
        }
    }

    /// Implementation for MoveSouthInstruction
    impl MoveSouthInstruction {
        fn discriminator() -> [u8; 8] {
            [146u8, 138u8, 196u8, 38u8, 130u8, 143u8, 149u8, 55u8]
        }

        pub fn data(data: MoveSouthInstructionData) -> Self {
            Self {
                accounts: MoveSouthInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MoveSouthInstructionAccounts) -> Self {
            self.accounts.state = AccountMeta::new(accounts.state, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.state.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MoveWest
    // ....................................................................

    /// Main instruction struct for MoveWest
    pub struct MoveWestInstruction {
        pub accounts: MoveWestInstructionAccountMetas,
        pub data: MoveWestInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MoveWest instruction
    #[derive(Debug, Clone, Default)]
    pub struct MoveWestInstructionAccountMetas {
        pub state: AccountMeta,
    }

    /// Account pubkeys for MoveWest instruction
    #[derive(Debug, Clone)]
    pub struct MoveWestInstructionAccounts {
        pub state: Pubkey,
    }

    impl MoveWestInstructionAccounts {
        pub fn new(state: Pubkey) -> Self {
            Self { state }
        }
    }

    /// Instruction data for MoveWest
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MoveWestInstructionData {
        pub p0: u64,

        pub p1: u64,

        pub p2: u64,

        pub p3: u64,

        pub p4: u64,

        pub p5: u64,

        pub p6: u64,

        pub p7: u64,
    }

    impl MoveWestInstructionData {
        pub fn new(p0: u64, p1: u64, p2: u64, p3: u64, p4: u64, p5: u64, p6: u64, p7: u64) -> Self {
            Self {
                p0,

                p1,

                p2,

                p3,

                p4,

                p5,

                p6,

                p7,
            }
        }
    }

    /// Implementation for MoveWestInstruction
    impl MoveWestInstruction {
        fn discriminator() -> [u8; 8] {
            [122u8, 187u8, 56u8, 38u8, 248u8, 122u8, 182u8, 106u8]
        }

        pub fn data(data: MoveWestInstructionData) -> Self {
            Self {
                accounts: MoveWestInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MoveWestInstructionAccounts) -> Self {
            self.accounts.state = AccountMeta::new(accounts.state, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.state.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: State
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct State {
    pub x: u64,

    pub y: u64,
}

impl State {
    pub fn new(x: u64, y: u64) -> Self {
        Self { x, y }
    }
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
