use fehler::throws;
use program_client::turnstile_instruction;
use trident_client::{anyhow::Result, *};

#[throws]
#[fixture]
async fn init_fixture() -> Fixture {
    // create a test fixture
    let fixture = Fixture {
        // We use the hardcoded system_keypair(0).
        // However the default option in the test template is now to use implementation of trait Default
        // for Client which will read keypair from "~/.config/solana/id.json" - (default path for `solana-keygen new`)
        client: Client::new(system_keypair(0)),

        // We use the hardcoded program_keypair(1) to ensure users can run these tests without the
        // need to modify the program ID in the program's lib.rs source file and in Anchor.toml configuraiton file.
        // However the default option in the test template is now to use the keypair generated by Anchor
        // located in target/deploy folder using the function anchor_keypair("name_of_your_program").
        program: program_keypair(1),
        state: keypair(42),
        user_initializer: keypair(45),
    };
    fixture
        .client
        .airdrop(fixture.user_initializer.pubkey(), 5_000_000_000)
        .await?;
    // deploy a tested program
    fixture
        .client
        .deploy_by_name(&fixture.program, "turnstile")
        .await?;

    // init instruction call
    turnstile_instruction::initialize(
        &fixture.client,
        fixture.state.pubkey(),
        fixture.user_initializer.pubkey(),
        System::id(),
        [fixture.state.clone(), fixture.user_initializer.clone()],
    )
    .await?;

    fixture
}

#[trident_test]
async fn test_happy_path(#[future] init_fixture: Result<Fixture>) {
    let fixture = init_fixture.await?;

    // coin instruction call
    turnstile_instruction::coin(
        &fixture.client,
        "dummy_string".to_owned(),
        fixture.state.pubkey(),
        None,
    )
    .await?;
    // push instruction call
    turnstile_instruction::push(&fixture.client, fixture.state.pubkey(), None).await?;

    // check the test result
    let state = fixture.get_state().await?;

    // after pushing the turnstile should be locked
    assert!(state.locked);
    // the last push was successfull
    assert!(state.res);
}

#[trident_test]
async fn test_unhappy_path(#[future] init_fixture: Result<Fixture>) {
    let fixture = init_fixture.await?;

    // pushing without prior coin insertion
    turnstile_instruction::push(&fixture.client, fixture.state.pubkey(), None).await?;

    // check the test result
    let state = fixture.get_state().await?;

    // after pushing the turnstile should be locked
    assert!(state.locked);
    // the last push was successfull
    assert!(!state.res);
}

struct Fixture {
    client: Client,
    program: Keypair,
    state: Keypair,
    user_initializer: Keypair,
}

impl Fixture {
    #[throws]
    async fn get_state(&self) -> turnstile::State {
        self.client.account_data(self.state.pubkey()).await?
    }
}
