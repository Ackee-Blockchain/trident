# Hello World Example for Trident Fuzzer

## Hello World program

This simple Solana Program Initializes StoreHelloWorld Account which stores one u8 field called input.
The StoreHelloWorld has a Program Derived Address.
```rust
#[program]
pub mod hello_world {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, input: u8) -> Result<()> {
        let hello_world_store = &mut ctx.accounts.hello_world_account;
        hello_world_store.input = input;
        Ok(())
    }
}
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub author: Signer<'info>,
    #[account(
        init,
        payer=author,
        space=8+100,
        seeds=[b"hello_world_seed"],
        bump
    )]
    pub hello_world_account: Account<'info, StoreHelloWorld>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct StoreHelloWorld {
    pub input: u8,
}
```

## Specify pseudo-random Accounts to reuse in Fuzzer
```rust
#[doc = r" Use AccountsStorage<T> where T can be one of:"]
#[doc = r" Keypair, PdaStore, TokenStore, MintStore, ProgramStore"]
#[derive(Default)]
pub struct FuzzAccounts {
    author: AccountsStorage<Keypair>,
    hello_world_account: AccountsStorage<PdaStore>,
    // No need to fuzz system_program
    // system_program: AccountsStorage<todo!()>,
}
```

## Specify Instruction data
```rust
fn get_data(
    &self,
    _client: &mut impl FuzzClient,
    _fuzz_accounts: &mut FuzzAccounts,
) -> Result<Self::IxData, FuzzingError> {
    let data = hello_world::instruction::Initialize {
        // input1 is randomly generated by the fuzzer
        input: self.data.input,
    };
    Ok(data)
}
```

## Specify Instruction Accounts
```rust
fn get_accounts(
    &self,
    client: &mut impl FuzzClient,
    fuzz_accounts: &mut FuzzAccounts,
) -> Result<(Vec<Keypair>, Vec<AccountMeta>), FuzzingError> {
    // create signer
    let author = fuzz_accounts.author.get_or_create_account(
        // randomly generated AccountID
        self.accounts.author,
        client,
        5 * LAMPORTS_PER_SOL,
    );

    // create the PDA for the StoreHelloWorld
    let hello_world_account = fuzz_accounts
        .hello_world_account
        .get_or_create_account(
            // randomly generated AccountID
            self.accounts.hello_world_account,
            &[b"hello_world_seed"],
            &hello_world::ID,
        ).unwrap();

    // specify Signers
    let signers = vec![author.clone()];

    // specify Instruction Accounts
    // No need to fuzz System Program so it can be constant
    let acc_meta = hello_world::accounts::Initialize {
            author: author.pubkey(),
            hello_world_account: hello_world_account.pubkey(),
            system_program: SYSTEM_PROGRAM_ID,
        }.to_account_metas(None);

    Ok((signers, acc_meta))
}
```

## Define Invariant Check
```rust
fn check(
    &self,
    _pre_ix: Self::IxSnapshot,
    post_ix: Self::IxSnapshot,
    _ix_data: Self::IxData,
) -> Result<(), FuzzingError> {
    if let Some(hello_world_account) = post_ix.hello_world_account {
        // The instruction Inputs are generated randomly.
        // We can tell the Fuzzer that if the number stored in the
        // StoreHelloWorld is 253 it actually found an Bug.
        if hello_world_account.input == 253 {
            return Err(FuzzingError::Custom(1));
        }
    }
    Ok(())
}
```

## Customize Instruction Generation
```rust
impl FuzzDataBuilder<FuzzInstruction> for MyFuzzData {
    fn pre_ixs(u: &mut arbitrary::Unstructured) -> arbitrary::Result<Vec<FuzzInstruction>> {
        // within the Hello-World Program we have only one instruction
        // that means this is not necessary. However, this way we can specify
        // instruction sequence that will be always generated by the fuzzer.
        let init = FuzzInstruction::Initialize(Initialize::arbitrary(u)?);
        Ok(vec![init])
    }
}
```
